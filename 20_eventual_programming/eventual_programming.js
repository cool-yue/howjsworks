/**
 * How Eventual Programming Works
 */

 // 初期就存在顺序(串行,sequence)编程.第一台计算机仅仅是无意识的计算器.
 // 你需要为一台计算机喂一些数据和一个程序,然后它会执行这些命令,一次只执行一条
 // 直到它创造一个结果然后停下来
 // 这种一次只执行一条语句的模型针对计算和大量数据处理,工作得很好

 // 第一个编程语言是在顺序时代开发出来的
 // 这些语言的影响力之大让大部分的现代语言仍然根植于它们的顺序范式
 // 老范式不能够预见到我们的程序现在需要做的事情
 // 导致现代系统的编程没有必要的困难,不可靠和不安全

 // 一个典型的顺序语言的特性就是阻塞输入和输出
 // 当一个程序试图从网络上面读一个文件,它会阻塞直到输入的操作完成
 // 这个在FORTRAN上面很有意义
 // 一个程序会阻塞当它需要在一个读卡器上读卡的数据
 // 程序这个时候啥也不做,直到数据完成后
 // 所以阻塞不是个问题
// 大部分的现代语言仍然实现的是FORTRAN的I/O模型
//JavaScript不是,JavaScript的第一个任务就是和人类进行交互
// 所以它更爱好一些的模型
// JavaScript相比大多数其他的语言来说比较不会被陷入顺序编程模型

/**
 * Concurrency
 * 并发
 */
// 顺序模型在电脑开始跟人,然后跟其他电脑交互的时候就不够用了
// 它需要并发编程,一次做多个事情的能力
//(这里做多件事值得商榷,因为只看线程的话JS还是只有一个线程,无非是把IO读写的东西给了其他线程去做
// ,而JS线程不停下等,继续处理后面的,这样形成一次做多件事的场景,而不是真的JS线程能够一次做多件事)

// 同类型的并发提供了提供了多个相同操作在同一时间发生
// 我们看一个例子,使用接收一个纯粹函数的数组方法,一次性处理数组中的每个元素

// 不同种类的并发提供了特定进程之间的合作,每一个进程有一个不同的职责
// 但是它们需要一起工作像一个团队一样
// 困难在于要保证团队人员不会像《三个臭皮匠》一样工作(互相导致不好影响)
// 这个确实是一个需要考虑的东西
// 臭皮匠的行为是一个坏的结构导致的不可避免的结果

/**
 * Threads
 * 线程
 */
// 线程是最老的不同类并行机制之一,现在仍然在用
// 线程是(正是或者虚拟)cpus在同一个时间运行同时共享同一片内存
// 运行纯粹的函数,线程能够很好地工作
// 如果函数不纯粹,臭皮匠就来了!

// 现在有2个线程,Moe 和 Larry,共享一个变量.
// Moe添加1到变量并且Larry添加2,就像你可以预测到的,结果是3

   Moe              Larry          variable
                                     0
variable += 1                        1
                  variable += 2      3

// 在这一次运行中,Moe先更改,也可以让Larry先去改。
// 在特殊性的情况下,谁最前赢得竞赛没有关系,因为操作是可以交换的,先加2还是先加1没关系的
// 如果Larry 使用 *= 而不是使用 +=然后这个结果可能就要看谁能够赢这个竞赛
// 也有其他的的输出还有其他的一些问题
// 以比较底层来看这个代码,+=赋值语句可以被编译成3个单一的机器指令：laod,add和store

Moe              Larry          variable
                                   0
load variable                      0
add 1          load variable       0
store variable   add 2             1
                store variable     2

// 这个演示了一个读-改-写的竞赛.
// Moe和Larry都取得了variable,当这个变量的状态是0的时候
// 他们都跟它们取到的值进行加,然后都存它们的和
// 这一次Moe的修改被覆盖了.另外一个时刻,Larry的修改被覆盖了
// 可能大多数时间,Moe和Larry不会都取同样的值,所以代码总是正确地运行

// 那个代码正确运行是可能的,但是它运行不正常也是可能的
// 这个潜在的问题在这极度简单的一行代码的程序中很难发现
// 但是在复杂的程序中,这些错误会隐藏得非常好

// 计算的负载的情况能够改变指令的交错执行
// 代码可能在开发和测试的运行好,但是在产品模式中就失败了
// 它可能一年都工作非常好但是在十二月失败了
// 线程中的间歇性的bug是最坏的,所有bug里面最昂贵的
// 当一个程序的行为被物理性的随机性影响
// 错误情形的复现基本上不可能
// 类型检查不能够找到它们(调侃了鼓吹type类型可以防止bug的情形)
// 测试不能够发现他们
// 错误可能发生得非常不频繁,然后让它们非常难以debug
// 也很难有信息让修复不会让事情变得更糟

// 线程竞赛的危险能够被互斥锁来减轻,这个互斥锁能够锁定重要的片区的内存
// 锁定线程,阻止他们他们执行,当有竞争的时候
// 锁的操作在计算上的代价非常昂贵
// 也有可能有一个锁定的线程不能够解锁
// 这个就叫死锁
// 另外一个失败的模式比较难以预防,复现或者修复

// 在Java(很多相似的语言)中的最大的设计错误是不能决定它到底是想成为系统语言还是应用语言
// write once,run anywhere
// 因为它尝试着兼顾两者,它需要在应用中用到线程,这个是不能原谅的

// 线程在操作系统中是一个必要的的罪恶.线程在应用中就是罪恶
// JavaScript不以这种方式使用线程,有一个更好的方式来获得并发操作

/**
 * Eventual Programming
 * 事件性的编程(这里如果直接按照eventual翻译的话,就是最后的,最终的,最终的编程感觉不知所云,姑且这里就叫事件性编程)
 * (一致性编程?这里不管怎么翻译,内容大致知道就行了,名称无所谓)
 */

// 一个事件性的函数是一个立即,可能在它请求的工作完成之前返回的函数
// 返回的结果在未来将会被事件性的交互,通过一个回调函数或者信息发送,这个结果并不是当做一个立即返回值来看

// 事件驱动提供了一种方式,这种方式管理多个活动而不需要在应用上面暴露线程
// 实际上,存在系统,让线程依赖于事件驱动来管理用户界面因为一个更简单更可靠的方式来在时间上处理事件
// 事件编程主要基于2点,一个是回调函数一个是处理循环(processing loop)

//一个回调函数是一个未来某个关心的事情发生之后将会被调用的函数,发生的事情主要有:
//.一个消息到达
//.一些工作完成
//.一个人类跟程序交互了
//.一个传感器监测到了什么
//.时间过了
//.一些东西错误了

// 一个回调函数被传到一个函数,这个函数开始一个活动或者监控一个活动
// 在更远古的系统中,回调函数被贴在一个对象上面,这个对象代表一个活动
// 在web浏览器中,一个回调函数通过向一个DOM特定的属性赋值从而把这个回调贴在一个DOM节点上

my_little_dom_node.onclick = callback function;

// 或者通过在一个对象上面调用一个事件注册方法
my_little_dom_node.addEventListener("click",callback function ,false);

// 这两种形式都能工作.当用户点击到这个特定的dom节点时,回调函数(又叫事件处理器)就被调用了
// 可能对这个事件就会反馈一些有用的行为

// 在时间编程中的另外一种想法就是处理循环(processing loop),又叫Event loop(事件循环)或者消息循环(message loop)
// 处理循环从一个队列中拿到优先级最高的事件或者消息,然后调用这个接受这个事件或者信息的回调
// 回调函数执行到完成
// 回调不需要纠缠内存锁或者互斥锁
// 回调函数不会被打断
// 所以就没有机会去竞赛
// 当回调函数返回
// 处理循环把下一个队里里的东西拿出来,然后继续执行
// 它是一个非常可靠的模型
// 这里面有相关的macro queue,micro queue,在node环境,浏览器环境等等

// 处理循环维持着一个队列,就是event queue(事件队列)或者(message queue)消息队列
// 这个队列持有进来的事件和消息
// 事件或者消息能够通过回调函数来引发,作为它们响应的一部分
// 很可能,事件和消息来自辅助线程,这些线程处理用户的输入,网络,I/O sysytem
// 和进程间通信
// 跟运行着javascript程序的主线程交互的方式是使用队列
// 互斥锁限制了这一点的接触,所以事件驱动系统倾向于更高效和更可靠

// 这个模型的一个意外的收益是JavaScript在web浏览器中是非常好地有适应力
// 当你打开一个debugger然后浏览网页的时候,你看见了几乎恒定的异常和失败
// 这个可能是很多web开发者并不擅长他们做的事情
// 然而呢,几乎所有的东西来起来都正常工作

// 在有多个线程的系统中,如果一个线程有一个异常,它的栈就被解开
// 那个线程可能在一个不持久的状态相对于其他线程,这个可能导致层叠的线程错误

// JavaScript使用一个单线程,大部分至关重要的状态都在它的函数闭包里面,而不是在栈上面
// 所以事情就能够保持运行
// 只要有一个按钮可以工作,用户就能够有效操作,而不会意识到大量的错误在下面已经在发生了

/**
 * The Law of Turns
 * 轮次的法则
 */

// 每一个处理循环的迭代都被称作为一个轮次(a turn)
// 这来来像棋类和扑克类的游戏,在任意一瞬间,只有一个玩家允许操作
// 玩家每操作一次,并且操作完成,玩家的轮次就结束了,只要游戏没有结束,另外一个玩家的轮次开始

// 游戏有规则,事件模型也有规则,规则是:

// Never Wait.Never block.Finish fast.
// 从不等待,从不主责,快速完成

// 轮次的法则应用于处理循环调用的回调函数,应用于它们调用的每个函数,直接或者间接的
// 一个函数不允许循环地去等待一些事情的发生
// 一个函数不允许阻塞主线程
// 在web浏览器中,像alert这样的函数不允许
// 在node中,带有-Sync后缀的不允许
// 一个函数花费太长时间做它的事情,是不允许的

// 触犯这个轮次的规则就会把一个高性能的事件系统转换成了一个低性能的系统
// 违反的事物不但导致当前回调的延迟,还延迟了在队列中的所有的东西
// 这个延迟能够被累加,这样就导致队列变得更长
// 系统就不能够快响应

// 所以任何违反的函数必须被修正或者在单独的进程中被隔离
// 一个进程就像一个不分享它的内存的线程
// 所以一个回调函数发送一些工作给进程非常合理
// 并且对于那个进程发送一个消息当它完成的时候
// 信息被放进队列,事件驱动来传输

// JavaScript完全不知道多个进程的存在
// 进程是javaScript运行的系统里面可以提供的服务
// 进程是事件驱动模型中的重要的部分
// 所以下一个语言进程将会是第一类特性

/**
 * Trouble In Serverland
 * 服务器领域的问题
 */

// JavaScript就是为了事件循环而创造,它表现得非常好
// 不幸的是消息循环更多是挣扎
// 这是因为一个服务器内部工作原理的本质非常不一样
// 在浏览器中,程序的工作大部分是响应UI的事件
// 一个事件处理器被调用
// 它做一些工作,更新显示,然后完成

// 一个服务器的典型的工作流要复杂得多.
// 一个消息接收方或者处理器被调用,这个可能又要跟其他的系统交互
// 在它能够传回响应的时候还需要定位到其他的机器
// 有时候从一个系统获的信息必须要跟另外一个系统交互
// 这样的操作可能有很长一条线,和其他系统交互的结果将会用回调来进行交互
// 有一个优雅的方式解决了这个问题,但是首先让我们看3种流行的错误方法

// 第一个错误叫回调地域.这是一种每一个回调函数包含请求下一个工作单元的代码的模式
// 那个请求提供了一个回调能够请求另外一个工作单元,所以
// 这样写的代码难于阅读,难以维护,并且脆弱

// 第二个错误叫Promises.在它们原始格式上,promise是聪明的
// 它们被开发出来支持安全,分布式(distributed)程序的开发
// 不幸的是当promise移植到javaScript来,他们失去了他们所有新的范式特性
// 所有剩下的是一个不方便的控制流机制
// Promise设计之初不是为了处理本地的控制流
// 这就是为什么他们没有做很好
// 他们确切的说是改进了回调地狱
// 但是他们又不让人满意

// 第三个错误是叫Async Await.它是一对关键字,用在修饰普通的顺序代码
// 然后魔法式地把它转换成事件驱动的代码
// 它跟ES6的generator写起来很相似,但是得到的东西完全不一样
// 值得赞扬的是,它掩盖了很多promise的不足
// 最喜欢它的事情是你可以继续用老的范式来写代码,那就是它的最大的问题

// 新的范式很重要.理解新的范式很困难,因为它是新的,但是这就是我们如何进步的
// Async await给了我们一个高产生的方式而不需要进步
// 他的用户写的代码,他们自己都不是完全理解
// 这不是一个好的想法.一个增长的问题是一个程序员把async和await到处去修饰
// 因为他们不理解他们做了什么,他们不知道怎么用好他们
// 我们不应该尝试否定或者隐藏下一代的范式
// 我们应该接受它

// 这3个错误东西的共同点是逻辑和控制流的紧耦合
// 这个造成了很差的内聚性因为有太多的不同行为的代码被粘贴在一起
// 分离它们更好

/**
 * requestors
 */

 // 我们应该模块化地设计.每个单元的工作,可能是创建跟某一些服务器的请求或者数据库的请求或者一个进程的请求,这些应该是分开的函数
 // 一个函数只做一个单元的事情就有很强的内聚性
 // 这些函数也接受一个回调作为它们的第一个参数.
 // 当工作单元完成,结果就被传入回调中
 // 这个减少了对其他代码的依赖
 // 给我们松耦合。这是一个好的模块化设计的实践,能够帮助我们完成新的范式

 // 我们使用单词requestor来标书一个函数接受一个回调和进行一个工作单元,这个工作单元直到未来的一个turn的时候才完成。

 function my_little_requestor(callback,value);

 // 一个callback函数接受2个参数,value和reason
 // value是requestor的结果或者undefined如果requestor失败了
 // 可选项reason能够被用来记录失败

 function my_little_callback(value,reason);

 // 一个requestor函数可以选择性返回一个取消函数.
 // 这个函数能够被调用以任何理由来取消这个工作
 // 它不是undo
 // 它仅仅是用来停止没有必要的工作
 // 所以如果一个requestor向另外一台服务器开始一个昂贵的的操作
 // 然后这个操作又不需要的时候,然后就调用requestor的cancel函数,这个函数可以发送一个停止的消息给服务器
 function my_little_cancel(reason);

 /**
  * Requestor Factories
  */

  // 你的很多工作是在创造一个传入参数来返回requestors的工厂
  // 这个工厂是一个简单的包装器,能够接收任何一个参数函数然后返回一个requestor

  function requestorize(unary) {
      return function requestor(callback,value) {
          try {
              return callback(unary(value));
          } catch (excepiton) {
              return callback(undefined,excepiton);
          }
      };
  }

  // 这个工厂创建了一个可以读在nodejs上面读文件的requestor
  function read_file(directory,encoding = "utf-8") {
      return function read_file_requestor(callback,value) {
          return false.readFile(
              directory + value,
              encoding,
              function (err,data) {
                  return (
                      err
                      ? callback(undefined,err)
                      : callback(data)
                  );
              }
          )
      }
  }

  // 最有意思的工厂创造的requestors与其他的服务以对话的形式交互很多次
  // 他们可以采用下面这个形式:

  function factory(service_address,arguments) {
      // The factory function returns a requestor function that can do a unit of work

      return function requestor(callback,value) {
          // 它在一个'try'的代码块中开始工作
          // 正好在发送函数发送信息到工作服务失败的时候
          try {
              // 当一个requestor函数被调用的时候
              // 它发送一个信息到服务
              // 告诉它开始工作
              // 当结果拿到
              // 这个结果会被回调函数传递
              // 在这个例子中,我们假定信息系统传送结果使用`(result,exception)`这个约定
              send_message(
                  callback,
                  service_address,
                  start,
                  value,
                  arguments
              );
          } catch (excepiton) {
              // 当异常捕获到,我们发布失败信号
              return callback(undefined,exception);
          }

          // 我们允许返回一个cancel函数
          // 这个cancel函数在这个请求的结果不需要的时候取消这个请求
          return function cancel(reason) {
              return send_message(
                  undefined,
                  service_address,
                  stop,
                  reason
              );
          }
      }
  }

/**
 * English
 */

 // Edsger Dijkstra 在1962年第一个发现多线程的问题的人之一
 // 他弄出了第一个互斥锁的机制,semaphores.
 // 一个信号标是通过2个函数来实现的,P和V
 // P意图是锁定重要区域的内存,阻塞caller如果它被锁了
 // V是解锁,允许一个等待的线程来锁定重要的内存和执行

// Per Brinch hansen 和 C.A.R. Hoare把型号表集成到类里面了来创造监控(monitors)
// 一个语法形式,为了提供更多遍历和错误的防御

// Java语言做了一个类似的事情叫做synchronized
// 它用synchronized关键字来修饰需要插入型号标的代码
// 不幸的是,他们选的这个单词说不通

// Synchronous意思是在同一个时间存在或者在同一个时钟里面使用
// 在管弦乐队的音乐人是syncronized因为他们都在照着指挥者的拍子来演奏
// 当java创立的时候,设计者寻找一个跟时间有关的单词
// 不幸的是,他们不够努力去找

// 当微软在尝试着为c#添加一个深度错误思考的的事件支持
// 它们看到了Java,用了一个错误的单词然后微软更错地添加了一个a的前缀来创造一个相反的单词
// async说不通！

// 大部分的程序员对并发的编程没有什么训练或者经验
// 同时处理多个活动流不够熟悉和陌生
// 给他们一些错误的行话不会让事情变得简单
// 它是无知的引导更加无知的。