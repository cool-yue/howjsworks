/**
 * How tail calls work
 */

 // 在我们的系统中,我依靠优化来让我们的程序运行更快.
 // 一个优化就是打破规则,但是以这种方式打破规则,打破规则不会被观察到
 // 一个优化不允许把一个好的程序转变成了一个坏的
 // 优化不允许注入bug

 // 最重要的优化不仅仅是不注入新的bug,它还终结了在好程序中的一类bug,产生了新的编程范式
 // 我在说的就是尾部调用优化(The Tail Call Optimization)
 // 一些专家认为这个优化很重要,我们不应该以一个优化来叫它的形式来轻视
 // 他们称呼这个为 Proper Tail Calls.任何其他实现tail calls的方式都是不正确的

 // 我更喜欢称呼它为优化,因为大部分的程序员几乎很少把重心放在这些规矩上
 // 他们喜欢优化,哪怕没有很大的效果
 // 我想他们需要这个功能

 // 当一个函数做的最后一件事是返回一个调用的函数的结果,一个尾调产生
 // 在接下来的例子中,continuize是一个工厂,接收any这个函数,然后返回一个hero函数
 // hero函数调用any,然后把返回的值传入到continuation函数

 function continuize(any) {
     return function hero(continuation,...args) {
         return continuation(any(...args)); // <-- 一个尾调
     };
 }

 // 当一个函数返回一个(正在执行调用的函数的返回值)
 // 我们称呼这个为尾调
 // 称呼为tail call而不是称呼为return call是个耻辱

 // 尾调的优化是一个简单,但是它有重大的实现细节
 // 使用传统的指令作为一个特征（metaphor）
 // continuize的代码生成可能包含这些机器指令:

 // call continuation # 调用continuation函数
 // return #返回一个调用hero的函数的地方

 // call指令把下一条的指令地址(这个案例中恰好是return指令)压入调用栈顶
 // 然后它转换控制权到一个函数,这个函数的地址在寄存器中标记为continuation
 // 当continuation函数执行完,它从栈中弹出return的地址,然后程序跳到return这里来
 // return的指令将要再次执行弹栈操作,弹出栈中的下一个指令,并且跳到调用hero指令后面的那条指令

 // 优化把这2个指令转化成一条指令

 // jump continuation #go to the continuation function

 // 现在我们不需要把return指令的地址压入调用栈,continuation函数返回到一个调用hero函数的地方,不是hero自身
 // 一个尾调想一个带有参数的goto语句,但是没有任何goto语句的危险,这些危险导致goto被废弃了

 // 所以它看起来是优化节约了一条指令,一次压栈,一次弹栈
 // 它看上去好像不是一个很了不起的事
 // 为了更好地去理解这个收益,让我们看看调用是如何在JavaScript中工作的
 // 当你调用一个函数,这些东西会发生

 //1.计算参数表达式
 //2.创建一个足够尺寸的活动对象(这个活动对象称呼为new活动对象)来装所有的函数的参数和变量
 //3.在这个new活动对象中存一个当前正在调用的这个函数对象
 //4.在这个new活动对象中存形参到实参的映射的值,缺少的实参被当做undefined,超出的实参忽略掉
 //5.在这个new活动对象中把所有的变量设置为undefined
 //6.在这个new活动对象中设置下一个指令字段(next instruction field),用来在这个调用完成后来引导调用函数后面的指令
 //7.在这个new活动对象中设置caller字段指向current活动对象
 // 这个current活动对象其实就是父作用域的活动对象,如果父是全局那么就是global 活动对象
 // 因为函数在使用之前先要申明,而在声明的过程中,就算在全局定义的函数,全局的代码本身也会当做一个函数体内的代码来对待
 // 因此在编译的过程中,全局的这个"函数"运行时,当然也会创建自己的活动对象,然后这个活动对象包含所有全局定义的变量,函数等
 // 在全局定义的函数内部就会有一个隐藏的引用,这个引用指向当前这个全局的活动对象
 // 在全局定义的函数真正调用的时候,current活动对象目前还是全局的活动对象
 // 函数自身的活动对象就会设置一个caller字段指向这个current,形成该函数的作用域链
 // 这里没有真正的调用栈,只有一个活动对象的链表

 //8.让这个new活动对象变成current活动对象
 //9.开始执行调用函数
 //10.如果函数中调用别的函数,继续上面的过程1

 //尾调情况的优化略微有点不同,过程如下:
 //1.计算参数表达式
 //2.如果current活动对象足够大
 //.使用current活动对象作为new活动对象
 //如果它不是足够大
 // 创建一个足够大的new活动对象来存放所有的函数的参数和变量
 // 从current活动对象中拷贝caller field到new活动对象中
 // 把current活动对象设置为new活动对象
 // 这一步就导致了new活动对象的一个caller引用到父级函数的活动对象
 // 这时候把虽然current切换切换了这个new活动对象,但是父级的活动对象依然存在别的引用指向它
 // 也就是这个caller,当函数return的时候,通过这个caller来交回控制权

 //3.在new活动对象中存放当前函数对象的引用
 //4.在这个new活动对象中存形参到实参的映射的值,缺少的实参被当做undefined,超出的实参忽略掉
 //5.在这个new活动对象中把所有的变量设置为undefined
 //6.开始执行调用函数

 //关键的不同点在于如果活动对象足够大,通常它都是足够大的,这样我们就不需要在新开辟一个新的
 // 我们现在可以复用current活动对象
 // 调用栈链不长,通常大概是几百个
 // 所以这个总是开辟单个最大尺寸的活动对象的实现很有意义,尾调迫在眉睫啊,赶紧使用
 // 内存分配的时间减少和垃圾回收都有很大的改善,还不止,还有更多

 // 有了尾调的优化,递归的函数能够变成跟循环一样快.这个对于函数式视角来说非常重要
 // 因为循环是不纯粹的.
 // 递归就纯粹了
 // 有了这个优化,对于递归的性能的争论就已经不用讨论了

 // 下面是一个总体来说的循环的结构
 while (true) {
    // do some stuff
    if (done) {
        break;
    }
    // do more stuff
 }
 // 一个尾调递归就像这样
 (function loop() {
    // do some stuff
    if (done) {
        return;
    }
    // do more stuff
    return loop(); // <-- 尾调
 }());

 // 上面演示了循环和尾调之间的对应关系
 // 递归函数会更优雅,在参数中传入更新后的状态并且返回值而不是使用赋值

 // 我们现在就可以让递归走更深而不会担心内存耗尽或者stack overflow的错误
 // 所以好的递归函数能够正确工作了
 // Proper Tail Calls不是一个特性,而是一个bug的修复
 // 标准需要这个优化的实现因为它对于阻止好的程序的失败很重要

 /**
  * Tail Position
  */

  // 一个调用是一个尾调,如果函数返回的值被返回了
  return (
      tyoeof any === "function"
      ? any()   // <--尾调
      : undefined
  );

  // 上面是一个尾调.返回一个表达式,但是下面这个不是尾调
  return 1 + any();// <--不是尾调
  // 函数做的最后一件事是返回了一个加法的结果
  any(); // <--不是尾调
  return;
  // 上面返回的undefined而不是返回的函数返回的值
  const value = any(); // <--不是尾调
  return value;
  // 这也不是一个尾调,因为它返回了value的值,我们知道value的值是any()的结果,但是那个调用不是在尾部的位置

  // 递归总体来说也不是尾调:
  function factorial(n) {
      if (n < 2) {
          return 1;
      }
      return n*factorial(n-1); //<--不是尾调
  }
  // 上面这个递归的调用不是尾调,所以它每一次迭代都生成了一个新的活动对象,但是我们可以移动那个调用到尾部
  function factorial(n,result = 1) {
      if (n < 2) {
          return result;
      }
      return factorial(n - 1,n * result);
    }
    // 这个版本就会被优化.递归的调用不会生成新的活动对象
    // 而是它们会调到函数的顶部
    // 它使用argument来更新参数,而不是通过赋值

    // 返回一个新的函数对象不是一个尾调
    return function() {} //<--不是尾调
    // 除非你立即调用这个函数对象
    return (function() {}()); // <-- 它是一个尾调

    /**
     * Exclusion
     */
    // 有些情况下优化会被取消,来防止好的程序变成差的程序
    
    // 在一个try语法块中的尾调就不能被优化
    // 优化可以节约时间和节约内存通过在调用栈中对这次调用不去链接活动对象
    // 但是try可能要发送控制权到这个调用的catch语句中,为了能够让那个放生
    // 活动对象就不能被优化而丢弃
    // 这就是另外一个好的理由来避免误用异常

    // 如果这个函数创建了一个新的函数对象,这个函数有自由变量,那么这个新的函数对象
    // 就有访问它的创造者的活动对象,所以活动对象也不能被优化而丢弃(闭包的情况)
    // 因为如果不这么做,就会出现变量访问的混淆,比如创建的这个新函数的外围每层都有相同名字的变量
    // 由于不创造新的活动对象,导致原始的活动对象参数值被覆盖掉,这个会引起很多的困惑

     /**
      * Continuation Passing style
      */

     function continuize(any) {
        return function hero(continuation,...args) {
            return continuation(any(...args)); // <-- 一个尾调
        };
    }
     // 在连续传入的风格中,函数接受一个额外的continuation参数,这是收到结果的函数
     // continuize工厂在这章节的头部分,能够把任何的函数转入一个函数,那个函数也接受一个continuation

     // 这种风格,continuation是一个代表着连续程序的函数
     // 函数永远往前执行,几乎不用重新访问当前的状态
     // 它是一个处理事件性的非常高效的工具
     // 它也用在了transpiling和其他应该中
     // 尾调的优化是仅有的可行的
    
      /**
       * Debugging
       */
      // 在调用栈上的活动对象的移除导致了debug更困难
      // 因为你不能看到导致到当前困境所有的步骤
      // 但是一个好的debugger能够减轻这个通过提供一种模式,这种模式拷贝每个对象的状态
      // 然后永远保持一个最近这些状态的小集合
      // 这个不干涉优化带来的好处
      // 而且我们可以监测传统的stack trace