/**
 * How Numbers Works
 */

 // 电脑是操作数字的机器
 // 操作数字基本上是所有的电脑都可以做
 // 他们看起来好像处理得确实非常好
 // 我们可以把其他种类的信息映射成数字（编码）
 // 电脑现在虚拟化影响人类所有的行为

 // JavaScript的数字是基于真实数字的灵感
 // 但是它们又不是真正的数字
 // 很多我们的数学理解和直觉可以应用到javaScript的数字上
 // 但是不是全部或者不能持久性地应用
 // 为了写一个javaScript的好的程序,我们需要知道javascript的numbers是如何工作的

 // JavaScript有一个单一的数字类型叫number
 // 它是借用的IEEE standard for floating-point arithmetic(IEEE 754)
 // 最开始为Intel's iAPX-432处理器所开发的
 // 432包含了很多聪明的想法,太多了
 // 432的结构变得太复杂,导致不能够完成它的目标
 // 他们就失去了最好的想法,简单性
 // 很多好的东西都是伴随着432而消亡的
 // 432的浮点(float-point)单元的挽回并且以8087来进行售卖
 // 8087是一个帮助8086的数学协处理器(co-processor)
 // 它变成了在奔腾和AMD64芯片上的标准设备

 // JavaScript总是被批评仅仅只有1个数字类型,但是这个实际上是一个最强大的东西之一
 // 程序员会更高产,如果他们不必纠结浪费时间去从一些类似的数值类型,
 // 让人困惑的这些中选择一个,而且还伴随着由于选择了错误的类型导致难以理解的执行失败的风险

 // 类型转换的错误避免了,由于int类型导致的溢出错误也避免了

 // JavaScript整数比Java的整数更可靠因为溢出不会发生

 // JavaScript 2147483647 + 1 // 2147483648 完全正确
 // Java 2147483647 + 1 // -2147483648 完全错误

 // 我们怎么样才能够对程序的正确性有信心,如果一个程序是基于一个number system,这个系统在任意时候可以导致非常大的错误而没有警告
 // int类型不能够防止错误,他们会导致错误

 // 在浮点(floating point)的背后的仅仅的一个简单的想法就是:用2个数表示一个数(换个说法,1个数描绘成2个数)
 // 第一个数(有时候称为coefficient(系数),significand(有效位),fraction,or mantissa)存着数字
 // 第二个数(称为exponent(幂指数))区分出10进制(或者2进制)的点应该在什么位置插入到第一个数中
 // 浮点的实现比较复杂,这个复杂来自于需要让有限个数的bit位的固定形式能够得到充分最大化的使用

 // JavaScript没有使用整个IEEE754的标准
 // 它用了java使用的ieee 754标准的子集的子集(java使用ieee 754标准的子集,而javascript使用了java的子集)
 // JavaScript的number非常接近Java的double
 // 它是64位二进制浮点类型
 // 这个数包含1个符号位,11个指数位和53个系数位
 // 一些非常聪明的编码可以让这个64位里面体现65位的作用?

 // IEEE 754,像很多在它之前出现的浮点系统一样,选择一个以2为基数.
 // 第一个数会被切成2个部分,符号位和系数位,符号位被放在了64bit中的最高位
 // 如果这个符号位是1,表示数是负数,系数被放在最低的那些bit位
 // 它能够正常得表示一个2进制范围的的分数
 0.5 <= significand < 1.0
 // 假设有n位,显然n趋于无穷的时候,能够表示二进制最大的分数
 // 1/2 + 1/4 + 1/8 +.... + 1/2**n
 // 这个等比数列的当n趋于无穷的时候,它的极限是 a1 * (1 - q**n)/(1 - q)
 // 其中a1 = 1/2,q = 1/2
 // 所以按照极限,这个是为1,但是计算机不可能有极限位,所以范围就是[.5,1)]
 
 // 在那个形式(科学计数法的形式)
 // 前面说到过通过指数幂来决定小数点怎么移动
 // 而significant这一部分转化成x.xx
 // 在数学中,人类用的是10进制,计算机用的是2进制,对于二进制,这个x只能是1,因为如果是2就进位了
 // 所以二进制的科学标计数法的系数位最高位总是1.由于那个位总是1,所以不需要存在数字中,这就是生成了一个福利位(bonus!)

 // 第二个数是幂指数,它填充了符号位和系数位中间的空挡
 // 所以一个64bit的数字以这样形式表示:
 // [1,符号位][11,指数位][52,系数位]

 // 一个数字的值用以下的方式来表示:
 // sign * significand * (2 ** exponent)

 // 但是有还有其他的复杂东西在里面.指数是代表一个偏移度的整数
 // 这个就可以非常容易地去比较,假定number是一个64位的整数的形式去比较
 // 符号位不同,比较第一位就知道了,然后紧跟着是权值,我们知道权值大的,后面的系数不用看了
 // 如果权值一样,在从高位到地位去比较系数,显然就是把这个当成64位的整数来看了.

 // 这样就可以提供了一个很大的性能收益,这个在50年前很重要
 // 指数也能够编码NaN和Infinity和低于正常值的值(一个特殊的格式代表非常小的数和0)

 /**
  * Zero
  */
 // 除了0就没有0了.在正确系统中,只有一个0.
 // IEEE 754标准有2个0,0和-0
 // 为什么会有正负0呢,因为数值系统中就有个符号位,而0只是以一种非常小的数来表示,并不是数学意义真正的0
 // 因为按照科学计数法,1.xx是不可能严格等于0的
 // JavaScript勇敢地努力在你面前尝试隐藏这个可恶的东西,而且几乎成功实现了这种影藏
 // 你可以安全地不理睬-0的存在,除了这些案例


 (1/0) === (1/-0) //false
 Object.is(0,-0) //false

 // 我不推荐你用0来当除数,我也不推荐你使用Object.is()

 /**
  * Number literals
  */
// 有18437736874454810627不可变的数字对象(number object),内建到JavaScript
// 每一个对象独立地代表一个数
// 一个数字字面量创造了一个对最接近这个数字字面量的数字对象(number object)的引用
// 有些时,他是准确的,有时它的偏移达到像9.9792015476735990582818635651842e+291这么大的偏差

// 一个整形的数字字面量就是简单的一个十进制数字的序列
// 通过使用一个进制的前缀以不同的基地(不同进制)组成一个数字也是可行的
// 所有的这些字面量都创造一个2018这个数字对象的引用

// binary: 0b11111100010
// otcal: 0o3742
// decimal: 2018.00
// hexadecimal:0x7E2

// JavaScript允许"进制指定字母"能够大写,但是把一个大写字母O放到一个数字字面量中当然会引起迷惑,跟0出现迷惑(有些字符大写O和0分不清楚)

// 十进制的数字字面量应该包含一个十进制的点
// 非常大或者非常小的数可能用e来紧凑地表示,它的含义是乘以一个以10为底的指数
// 比如6.0221408e23就是6.02214083 * (10 ** 23)的缩写
// 然后6.626e-34是6.626 * (10 ** -34)的缩写

// Infinity是一个值代表所有的那些太大而不能被展示的数
// 不要把Infinity跟数学的无穷搞混了,数学里面它不是一个值,而是一种隐喻

// NaN是一个特殊的值,这个值代表不是数的值.NaN是Not a Number的意思
// 有一个困惑的是typeof操作符去操作NaN返回的是number

// NaN可以是一个失败的字符串转数字的结果,这种情况不是给一个异常或者让程序停止,这个时候给你的结果是一个NaN
// 算数运算符创造一个NaN当NaN是它们的输入的时候

// 关于NaN最糟糕的事情是NaN跟它自己不相等.这是一个JavaScript没有盖住的IEEE 754标准中令人憎恨的东西
// 检测NaN的相等跟其余的所有的数字都不同
// 这个可能是一个危险的地方,当检测的时候
// 如果期望的值是NaN,检测永远会失败,甚至实际值就是NaN
// 检测一个值是否是NaN,用Number.isNaN(value)
// Number.isFinite(value),如果值是NaN,Infinity或者-Infinity,返回的都是false

/**
 * Number
 */
// Number构造器(不是number,这个首字母的大写N很关键)是一个函数可以创造一个numbers;
// Numbers在javaScript中是不可变的对象
// typeOf操作符返回"number"(首字母是小写)
// 你不应该使用new这个前缀来调用Number函数
// 它不会做你觉得应该做的事情

const good_example = Number("432");
const bad_example = new Number("432");
typeof good_example // "number";
typeof bad_example // "object";
good_example === bad_example //false

// Number同样也是一些常量的容器
// 常量可以提供数字如何工作的内部视角

// Number.epsilon差不多是2.220446049250313080847263336181640625e-16
// 它是最小的正数
// 注意这个最小的正数的意思,它的意思是这个正数 +  1 > 1的最小正数了,比它小的数就变成了 x + 1 = 1了
// 这里问题是,x虽然小,但是x不是0,它跟0是不一样
// 而Number.MIN_VALUE是能表示的最小数,低于这个数就跟0视为一样的,就像数学的极限一样
// 而高于这个值也是满足 x + 1 = 1,但是它又不是0

// 从小到大的正数如下
// 0 这个区间的数全是0 Number.MIN_VALUE  这个区间的数不是0,但是它们太小了+1 = 1   Number.EPSILON


// 当它跟1加的时候,创造的和大于1
// 添加任何小于Number.EPSILON到1都创造一个等于1的结果
// 这看起来非常的荒谬一个非0的数加上1得到1
// 这不是JavaScript的bug或者设计错误
// 所有的固定尺寸的浮点系统都有这样的怪异东西出现,包括IEEE 754
// 它是一个合理的妥协

// Number.MAX_SAFE_INTEGER差不多是9007199254740991或者差不多是9倍的千的5次幂（9 quadrillion）在现代的的"illion"习语中
// 2**53 - 1 = 9007199254740991,意思就是53位的系数位,能够表示的最大整数是这个

// JavaScript没有一个或者不需要一个整形,因为它的数值类型能够精确表示所有的整形数直到Number.MAX_SAFE_INTEGER
// JavaScript有54bit的带符号的整形数在它的number类型中（1bit表示符号,53bit表示数值）

// 1加上一个比Number.MAX_SAFE_INTEGER大的数跟一个0加上那个大数的结果是一样的.
// JavaScript具备准确的整形计算,如果计算的数,结果,中间结果都在-Number.MAX_SAFE_INTEGER和Number.MAX_SAFE_INTEGER之间
// 有了这个范围,普通情况下的计算都能够驾驭得了
// 结合律和拆开律都是有效的

// 如果在那个范围以外,事情就更混乱了
// 例如加法中的数字的顺序会影响最后的结果所以
// ((0.1 + 0.2) + 03) 创造了一个比 (0.1 + (0.2 + 0.3))要大的结果
// Number.isSafrInteger(number)返回true,如果数字在安全的范围中

// Number.isInteger(number)返回true,如果number是个(整数并且在安全的范围中)也(可以在安全范围外的数,可以不是整数,但是这个方法返回的是true)
// 所有的大于Number.MAX_SAFE_INTEGER的数都被考虑成整数,有些确实是对的,但是大部分是错的

// 为什么会有这个范围,可以这么来想,我的系数有53位,1.[52位],如果我要表示一个整数,那么只需要通过幂指数移动小数点 
// 小数点后面的全部置0,而现在的问题在于,我53位如果全部成了有效位了,也就是幂指数已经是52了,1.[52位]
// 就成了[53位]表示的整数了,也就会2**53 -1,53个1
// 现在的问题在于再要大怎么办?现在幂指数还能往上抬,但是每抬一位幂指数,就相当于原数*2了
// 那么系数就要相应调整,比如现在是53个1,然后幂指数是52
// 如果我要表示比53个1大1的数,显然系数目前不能再大了,那么只能先动幂指数,幂指数+1操作,二进制相当于乘以了2
// 这个时候相当于是[1..50个1..11]0 这样的数,显然系数又要调整,[10...50个0...0]然后幂指数是53
// 好,现在继续往上加,我要再去一个大1的数怎么办?系数最小的变动就是[10...50个0...1]然后幂指数还是53,这个结果是目前能够向上+的最小结果
// 但是这个结果最终表示的是 [10...50个0...1]0 这个整数,这个由于权值已经超越了这个52位小数,所以系数每加1就是相当于是加2了

// 抽象到十进制来看,假如我只有5位系数位,10进制
// 9.9999 * 10**4  === 99999,这是我能表示的最大的整数
// 如果要表示1 0000,那么我的幂指数就要+1,变成5
// 1.0000 * 10**5,这个可以
// 如果我继续要加1,这个时候我能表达出来的往上加的最小数为
// 1.0001 * 10**5 == 100010 !== 100001
// 有限的空间,我已经不能正确表达整数了。

// Number.MAX_VALUE存着JavaScript能够表示的最大的数差不多是Number.MAX_SAFE_INTEGER * 2 ** 971
// 1.7976931348623157e+308

// 这是一个1后面跟着308位.大多数都是幽灵(phantom,没有实际显示出来),这些数能够提供15.9位显示的数,
// 后面的292位数是被2进制转化到10进制生成的画面(详细见书上)

// 在Number.MAX_VALUE上面增加任何的正安全数创造的和还是Number.MAX_VALUE
// 它就像如果一个程序生成了一个Number.MAX_VALUE的结果,然后程序就出错了
// 所有超过Number.MAX_VALUE的值都应该被怀疑.IEEE 754标准承诺潜在的可数范围(安全范围)
// 如果没有去关心这个 ,很可能造成错误

// Number.MIN_VALUE是最小比0大的可以表示的数.它准确等于2 ** -1074

// 所有的正数比Number.MIN_VALUE小的就跟0没有区别
// 注意到Number.MIN_VALUE的系数只包含一个单一的bit位在系数位置的最低位
// 那些孤独的bit位创造了太多幽灵系数

// Number.prototype是一个对象,所有number是继承Number.prototype,它是一个包含一些方法的对象
// 不幸的是,没啥用

/**
 * Operators
 */

 // 前缀操作符(prefix)

 // +
 // 转成number(to number)
 // +这个符号,前缀操作符把它的操作数转成一个数字,如果转化失败,它就生成一个NaN.使用Number函数转化更好,因为它更明确

 // -
 // 负
 // -减号符号,前缀操作符改变了它的操作数的符号。在JavaScript中的数字字面量是没有符号的
 // 像一个表达式(-1),这个减号是一个操作符,而不是数字字面量的一部分

 // typeof
 // 类型是
 // 如果操作数是一个数,它会创造一个字符串"number",甚至操作数是NaN也会是"number"

 // 中间操作符(infix)

 // +
 // 加(addition)
 // 不幸的是,+操作符也会被字符串来用作拼接,这个过度使用创造了一个危险.如果有一个操作数是字符串,那么它会把另外一个操作数转化成字符串然后拼接它们
 // 不幸的是,没有其他的方式来做加法了,所以你必须要小心谨慎.Number函数在确保操作数当做+符号的中间运算符(加法)来对待
 // 能够让这个符号起到加法的作用

 // -
 // 减法(subtraction)

 // *
 // 乘法(multiplication)

 // /
 // 除
 // 这不是一个整数的除法(不返回整数).如果你把2个整数进行除操作,你可能会得到一个分数的结果:5/2生成2.5而不是2

 // %
 // 取余(remainder)
 // JavaScript没有取模的操作符,取而代之的是一个取余操作符,我认为取模更有用,取余的结果是从被除数中拿到它的符号,而取模是从除数拿到它的符号
 // -5%2 = -1

 // **
 // 指数(exponentiation)
 // JavaScript采用FORTRAN的双星花来提供给语言一个有趣,老旧的样子

 /**
  * bitwise operators
  */

  // JavaScript有一组位操作符和在c还有其他语言中看到的很相似
  // 这些操作符操作JS的数字通过转化它们到有符号32位整形数
  // 运行位操作,然后转化回JS number
  // 如果它们在54比特位的安全整数操作的话就会更好
  // 但是它们不是,所有22个高比特位没有警告地丢失了

  // 在一些语言中,一个移位用来代表乘或者除或者一个位与操作可以用来当做一个取模运算符
  // 如果你在这个语言中做这种操作你可能会丢弃那22个最高位
  // 在某些情形你要抛弃这些高位,有些时候你不能抛弃

  // 这就是为什么位操作符在JS中相比其他语言用得很少
  // 但是虽然他们没有被使用,他们也是一个语法危险领域
  // &和| 容易跟 && 和 || 搞混
  // <<和>> 容易和<和>搞混
  // 对我来说为什么>>做了带符号的右移而>>>没有做无符号右移不太明显
  // 在c中,符号的扩展是被类型所决定的
  // 在java中,符号的扩展是被操作符决定的
  // 所以JavaScript复制了Java的坏的选择
  // 要留心这里啊

  // 唯一的位的一元操作符是~,非操作
  // 位二进制操作符:

  // &,位的与
  // |,位的或
  // ^,位的异或
  // <<,左移
  // >>>,无符号右移
  // >>,带符号右移

  /**
   * The Math Object
   */
  // Math对象包含一组应该放在Number中的函数
  // 这是另外一个Java的坏的影响

  // 除了三角和对数函数,它包含了应该是操作符的函数

  // Math.floor 和 Math.trunc都是从一个数中创建了一个整数
  // Math.floor给更小的整数,Math.trunc给更靠近0的的整数
  // 这些主要是为了在于你想对负数做什么样的事情
  Math.floor(-2.5) // -3
  Math.trunc(-2.5) // -2

  // Math.min和Math.max返回最小的或者最大的实参
  // Math.random返回一个在0到1之间的数,它比较适合游戏,但是不适合那些加密应用或者博彩游戏

  /**
   * The Monster
   */
  // JavaScript不会提供把一个数解构成为它的几个组件的工具
  // 但是我们可以简单地用JavaScript写一个这样的工具
  // 我们能够看一个数的真实本质东西

  // 我决定用coeffcient代替significand因为我想要在整数的空间能够完全地工作,这样就会比较清晰和准确
  // 分数的系数需要更多的解释
  // 这里有一波代码分析,详细见code.js
  // 通过代码我们传入一个0.1试一试
  // 得到如下的东西:
  {
     "sign":1,
     "coefficient":72057559403792794,
     "exponent":-56,
     "number":0.1
  }
  // 当你做数学 1*72057559403792794*2**56它不是0.1它是0.1000000000000000055511151231257

  // JavaScript在你的程序中处理10进制的小数非常差劲
  // JavaScript不能够准确地代表一个值,所以化名用一个自己能够表达的值去代替这个值

  // 当你在你的程序中输入小数点的时候,或者读到一个有十进制小数点的东西的时候,
  // 你的程序好像就引入了一些小错误,有时候这个错误非常小以至于他们没有察觉
  // 有些时候这些数的误差互相抵消了,有些时候这些错误累积起来了

  // 当我们解构0.3的时候,我们拿到跟(0.1 + 0.2)的一个不一样的值
  {
    "sign":1,
    "coefficient":5404319552844595,
    "exponent":-54,
    "number":0.3
  }
  {
    "sign":1,
    "coefficient":5404319552844596,
    "exponent":-54,
    "number":0.30000000000000004
  }
  // 注意到既不是0.29999999999999999也不是0.30000000000000444而是真正的0.3

  // 让我们再来看一例子,当我们结构100/3,我们拿到
  {
    "sign":1,
    "coefficient":9382499223688534,
    "exponent":-48,
    "number":33.3333...333333336
  }
  // 注意到JavaScript说这个数是33.3333...33336.最后的这个6就是一个JavaScript不能够清楚正确答案的标志,甚至是一个合理的答案
  // 但是事实更坏.JavaScript实际上认为准确答案是33.3333333...3333357018....

  // 浮点系统里面的函数把内部的二进制的表示转化成外面人类坚持使用的十进制的表示
  // 这些函数被设计出来是为了掩盖真实的东西(这个真实的东西就是javascript不能够完全准确表示所有的小数)到一个它能够掩盖的程度
  // 比较担心的是我们一直被强制经历IEEE754这个真实情况,我们要反抗这个并且需要一些更适合的东西
  // 以实际为基础,我们不想在我们的运算结果中看到残缺杂质,我们不想把这个残缺杂质显式给我们的客户
  // 这会让我们看起来很不称职,当然如果我们假装一切都是正常的,那么这个解决方式显然更容易些(讽刺)
  // 当你数钱的时候,你需要守规则地需要拿到一个正确的和

  // 那是在半个世纪前.从那时起,我们已经忘记了二进制浮点带来的妥协
  // 我们应该从现在起转移到更好的东西上面
  // 在21世纪,我们不能够可靠地让0.1 + 0.2得到0.3是不可原谅的
  // 我希望那个代替JavaScript的语言能够独占一个单独的number类型，这个类型能够精确表达十进制小数
  // 这样一个系统仍旧不能准确地表达一个真实的数
  // 没有有限的系统可以,但是它可以正确地表示对于人类最重要的数字,10进制数表示的数

  // 在这期间,尝试尽可能地使用安全整数范围.
  // 我推荐把所有的钱的值都转化成分,那样它们就能正确作为整数来表示
  // 危险就是在不这么做的代码和不这么做的系统交互的时候
  // 这样一个接口错误创造出来的结果导致100倍大或者小
  // 那样非常糟糕,可能通货膨胀能够让美分非常不值从而钱拯救我们来避免这个困扰

  // 当你在安全整数集外面做事的时候,数字包含一个.或者一个e,这个可能并不是准确的值
  // 与几个有相似的系数相加的和相比,单独先算每个不同的系数最后相加的和,前者更准确