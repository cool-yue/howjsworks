/**
 * How Date Works
 */
// 我们的日历提供者太阳和月亮在稳定的时间推移上的运动的信息
// 但是这是在探索出太阳系如何工作的很长时间之前就设计得
// 它被补丁了很多次,但是从来没有被完全修复
// 我们畸形变形的日历被越来越大的组织以压倒性和商业性的方式来强制推行
// 最终它被全球组织推行但是第一时间去修正或者以更适合的设计来替代它
// 它可以工作,全世界都以它为准来运行,但是它可以变得更好

// 我们现代的日历是基于罗马日历,这个罗马日历最初是有10个月和一个来装剩余的天数的额外冬季时间
// March(是根据Mars来命名,战神)是第一个月
// December(是第十个个月)
// 冬季时间被2个新的月份替代,一个是January和february
// 天数有时候为了政治目的从二月里面偷一点然后用来扩展其他的月
// 日历每4年要漂移一天或是因为一年中的天数不是一个整数(回归年的天数不是一个整数不是罗马人的错)
// 他们准备方便地调整他们的日历通过申明January是第一个月,December(仍然是第十个个月)变成第十二个月

// julius建立了一个标准,这个标准是每4年把一个闰日(leap day)加到二月里面
// 这个减少了季节的漂移,但是没有完全消除它
// Gregory标准化了一套更好的闰日算法,但是一个更简单更准确的算法从来没有被采用
// The Gregorian algorithm
// 年份能够被4整除除非同时不会100整除那么就添加一个闰日
// 如果年份能够被400整除那么绝对要添加这个闰日

// 那样就生成了一个平均值365.2425天,这个真的是非常接近回归年,大概是365.242188792天

// 有一个更好的算法:
// 添加一个闰日如果能被4整除而不能被128整除
// 这个创造出365.2421875天一年,这个就更接近回归年
// 这个在算法中的两个2的指数的数的结合,对于我这个作为程序员的人感觉很神奇
// 尽管让我影响更深的是它是否能够匹配真实的年
// 如果一年的天数是一个整数,我想可能会有些事实在这个聪明的设计的想法中

// 下一年在4|100|400和4|128算法有分歧的是2048,,在那之前我们应该标准化4|128

// 闰日用来加到一年的末尾,不幸的是,当January变成1月时,他们不会把这个闰日从二月移到十二月(还是第十个月)

// 分和秒是以0作为原点的值,这个很好,他们都是60位模,这个不够好,小时是基于0的,但是12小时的时钟用12来表示0,这个很奇怪

// (如果我可以,我将会让一天有10个小时,一个小时100分钟,一分钟100秒,我的秒可能会短些,是当前秒的86.4%,这可以是一个漂亮的节奏
// 一个在生活中的非常绅士的改进在当前缓慢的节奏之上)

// 月份和天是以1为起始值因为它们已经在0被探索出来之前就已经标准化了
// 月份是以12为模,罗马人想要让月份是以10为模,但是如果那样他们不能够让它工作
// 一个月的天数是以30为模或者31或者28或者29,取决于月份和年份
// 年份是以1位起始,但是当前年份的数字已经采纳了很多世纪了在共同年代以(Common Era epoch)后
// 所以我们能够安全地忽视掉那个不方便

/**
 * The Date Fucntion
 */

 // 计时的标准的怪异性对于必须处理时间的程序来说是一个危险的东西
 // Java的Date类提供了对于日期的支持
 // 它本应该是个简单的东西,但是它变得很复杂,演示一个最差的类风格编程
 // JavaScript能够有意义地做一些更好的东西
 // 但是相反的是,它拷贝了Java的非常差的例子

 // 今天的JavaScript的Date对象伴随着及其多的方法
 // 很多方法只是getter和setter

 // getDate getDay getFullYear getHours getMilliseconds getMinutes getMonth
 // getSeconds getTime getTimezoneOffset getUTCDate getUTCDay getUTCFullYear
 // getUTCHours getUTCMilliseconds  getUTCMinutes getUTCMonth getUTCSeconds getYear

 // setDate setFullYear setHours setMilliseconds setMinutes setMonth setSeconds setTime
 // setUTCDate setUTCFullYear setUTCHours setUTCMilliseconds setUTCMinutes setUTCMonth setUTCSeconds
 // setYear

 // toDateString toISOString toJSON toLocaleDateString toLocaleString toLocalTimeString
 // toString toTimeString toUTCString

 // 有一个getDate方法从一个日期对象中返回月份的哪一天,你可以立即发现单词Date有2个不同的意思在同一个方法里面
 // 混合在一起,也有一个getDay方法,返回一周的哪一天

 // 有一个getMonth方法修正了Month从0开始,因为程序员喜欢那些从0开始的东西
 // 所以getMonth返回一个介于0和11之间的数
 // getDate方法没有修正day,所以它返回的数字从1到31
 // 这种松散的不一致是错误之源

 // getYear和SetYear方法在1999年以后就不能够正确工作了,所以不应该使用
 // Java是1995年出来的并且包含会在2000年失效的date方法
 // 他们听过Y2K问题吗？或者他们怀疑Java能够在市场上生存足够长,长到那个问题的发生
 // 我们不知道,我们知道的是,Java令人难以理解的生存下来了并且JavaScript犯了一样的错误
 // 永远使用getFullYear和setFullYear

 // Date在类编程中演示了一个非常差的实践
 // 一个对象应该封装一些东西.
 // 用对象交互需要有事务性和其他高级别的活动
 // Date是以getter和setter针对每个时间的独立组件的这种非常低层的形式暴露在外面
 // 这种实现方式没有把对象用好

 /**
  * ISO 8601
  */
 // new Date构造器能够接收一个字符串,这个字符串表示一个日期,然后以这个日期来创建一个对象
 // 不幸的是,ECMAScript标准没有指定解析和识别的规则是什么
 // 所以根据标准,它不能够保证工作

 // 除了ISO dates

 // ISO 8601是一个表示日期和时间的国际标准
 // JavaScript被要求来正确解析ISO日期,就像2018-11-06
 // 把最有意义的东西放在第一,把最没有意义的东西放在最后,是非常有道理的
 // 当然比美国的标准更有意义 11/06/2018,例如,我们能够排序ISO日期字符串

 /**
  * A different Approach
  */
 // 当然现在做正确的事情太晚了
 // JavaScript不应该拷贝Java
 // 那个总是错误的
 // 很多错误是JavaScript来自Java

 // date应该有3个表示:

//.从纪元(通常是1970-01-01)开始秒数的数值
// .一个data对象包含下面的属性
// year month day hour minute second zone week weekday

//. 一个在某些标准格式中的字符串

// 我们不需要类风格的带有方法的Date对象
// 我们只是需要简单的函数䣂做转换,在上面三种形式之间

//Date.now()
// 返回当前的时间的数值。这个函数已经存在了,javaScript然这个函数在所有代码中都可用
// 但是我认为它需要一个只在信任的代码中才有权利使用
// 一段神奇的代码可以使用Date.now()和Math.random()来改变它的行为,让它避免被监测

//Date.object()
// 这个既可以接受一个数或者一个字符串,返回一个包含信息的对象,这些信息可以被抽取出来
// 当参数是一个字符串的时候,可以有额外的可选的参数来决定时间区域(time zone)并且标准格式来驱动解析

//Date.string()
//这个将会接受一个数字或者一个数据对象并且一个可选的格式标准和时间区域(time zone)
// 返回一个人们可读的时间的字符串

//Date.number()
// 这个可以接收一个数据对象或者字符串和一个可选的格式标准和时间区域(time zone)
// 然后返回时间的数字表达的形式

// 这个实现会简单很多,使用简单很多,更多的错误防御,并且对Y2K做准备(虽然现在不是个问题)
// 它只是一个不纯的函数和三个纯的函数而不是那一大池子底层的不纯的函数
// Java不能够做这个,因为Java没有JavaScript这个可爱的对象字面量
// 我不知道为什么JavaScript不怎么做,我希望下个语言可以这么做

// JavScript使用的epoch是Unix的:,1970-01-01.
// 有32bit Unix系统的话,它会在2038年失效, 这个时候所有的bit位都用完了并且时钟溢出
// 被证明是32bit 是不够跑一个系统,这个系统时钟是以秒位为单位

// 我更喜欢0000-01-01作为epoch.JavaScript数字将不会失败地累加毫秒到285426
// 我们也会想出一个更好的日历,可能我们也会灭绝.
// 祝你有个美好的一天!