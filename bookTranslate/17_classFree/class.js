/**
 * how Class free works
 */

 // 在面向对象编程中的一个关键的理解是一个程序的各个部分之间交互和通信的模型
 // 想象一个方法名和它的参数作为一条信息
 // 调用方法传送信息到一个对象
 // 当它接收到特定信息时,每个信息都触发自己的行为
 // 发送者角色接受者知道用那个信息来做什么

 // 从这里面掉出的一个东西之一就是多态
 // 每一个对象能够识别一个特定的信息就有资格接受那个信息
 // 下一步发生什么是依赖于对象的具体实现
 // 这是一个非常牛逼的想法

 // 不幸的是我们被继承把注意力带偏了
 // 继承是一个牛逼的代码复用的机制
 // 代码复用很重要,因为它让我们能够减少开发一个程序的工作量
 // 继承创建了一个同样被预料到的观点
 // 我们可以说一些对象或者对象的类和一些其他的对象或者对象的类一样除了一些重要的不同点
 // 这个工作得很好当事情简单的时候
 // 我们应该记住现代面向对象是从smallTalk开始的,这是一个为孩子设计的
 // 当事情变得复杂时,继承就变得有问题了
 // 继承导致了类的紧耦合,一个类里面的改变能够导致依赖它的类失败
 // 类更倾向于是一个失败的模块

 // 我们同样也看到很多注意力都放在了属性上,而不是放在对象上
 // 存在过于强调每个单个属性的getter和setter方法
 // 或者在最坏的设计中,属性是公共的并且能够不被对象察觉地被修改
 // 尝试好的设计是可行的,属性被隐藏,方法处理事务,不仅仅是属性的修改
 // 但是它并不是经常发生

 // 还有一个就是过分依赖于types(类型),类型是FORTRAN的一个特性和
 // 类型对于编译器的作者来说很便利的后来出现的语言
 // 从那时起,关于类型的神话开始越来越兴起
 // 过分地宣称类型能够保护程序不出错
 // 尽管投身于类型,然而错误仍然每天都出现

 // 类型获取信任,并且值得这个信任,通过编译器在早期就能够发现错误
 // 越早发现一个bug,开销就越小
 // 但是如果程序以正确的方式测试过
 // 所有这些bug都能够很快找到
 // 所以通过类型识别出来的bug都是没啥价值的bug

 // 从来不会给类型没找出bug来责备它,昂贵的bug
 // 通过需要规避类型的时候,类型导致的出现错误,也不会被追究
 // 类型能够诱导我们接受含义隐晦,杂乱的,没有把握的编程实践方式

 // 类型就像瘦身餐.这种配餐对于减重能够得到信任
 // 从来不会把体重又回来了甚至增加了归咎于瘦身餐上
 // 从来不会把它引起的健康问题和痛苦归咎于瘦身餐上
 // 瘦身餐给了我们信心,我们吃不健康的食物,我们也可以获得一个健康的体重

 // 当我们继续创造更多bug和遗产代码时候,类的继承会让我们想到我们在写一个好的程序
 // 如果你忽略这些消极的东西,类型感觉是一个大胜利
 // 有益的地方确实有,但是如果你系统性地看类型,开销超过了收益

 /**
  * constructor
  */

  // 在13章(generator)中,我们以工厂的形式来实现功能(函数返回函数)
  // 我们现在可以跟constructor(函数返回包含函数的对象)相似的是东西
  // 我们以创造一个counter_constuctor,这个函数根counter generator相似,他有2个方法,up和down

  function counter_constructor() {
      let counter = 0;
      function up() {
          counter += 1;
          return counter;
      }
      function down() {
          counter -= 1;
          return counter;
      }

      return Object.freeze({
          up,
          down
      })
  }

// 返回的对象被冰冻了.
// 对象不会被破坏或者损坏
// 对象是有状态的
// counter变量是对象的私有属性
// 它只能通过方法来访问
// 我们不必非要用this

// 这个很重要.对象的接口是它的方法
// 仅仅是它的方法
// 对象有一个非常硬壳子
// 这个给了我们最好的封装
// 没有直接访问数据的权利,这是一个好的模块设计

// 一个构造器(constructor)是一个返回一个对象的函数
// 构造器的参数和变量变成了对象的私有属性
// 没有共有数据属性
// 构造器的内部函数变成了对象的方法
// 它们掩盖了私有属性
// 放入了冰冻对象的方法是公共方法

// 方法应该实现事务性.例如,假如我们有一个person对象
// 我们可能想要支持改变person的地址信息
// 我们不应该有一个分离的set函数来改变address中的每个单独项目
// 我们应该有一个单个方法接受一个可以描述所有的需要修改的address的部分的对象字面量

// 在javaScript中一个很聪明的想法是对象字面量这个东西
// 它是一个很愉快同时也是很昂贵的聚集数据的语法
// 通过创造消费和生产数据对象的方法
// 我们能够减少方法的数量,增加对象的集成度

// 所以我们有2个类型的对象:

// 硬编码对象只包含方法.这些对象保护着闭包里面的数据的完整
// 他们给我们多态性和封装性

// 软数据对象只包含数据,这些对象没有行为
// 他们仅仅是能够被函数操作的非常方便的集合

// OOP的一个观点起始于在一个COBOL记录中添加处理过程(adding of procedures)来提供行为能力
// 我认为方法和数据属性的结合是一个重要的进步
// 但是它也不是最后一步

// 你应该包含一个toJSON方法如果hard object需要被stringify
// 除此之外,JSON.stringify把它dangchen一个空对象来看,不管它的方法和隐藏在里面的数据

// 也就是函数并不会被打印出来
//aaa = {getA:function() {return this.a}}
//JSON.stringify(aaa)
//"{}"

/**
 * constructor parameter
 */

 // 我有一次写了一个有10个参数的constructor.它非常难以使用,因为没有人记得这个顺序
 // 后来,我们注意到都没有人可以很好地用第三个参数,
 // 我想要把它移除参数列表
 // 但是那样会破坏我已经写好的程序

 // 我之前要是明智的话,我应该让这个constructor接受一个单个对象作为它的参数
 // 这个通常下是一个对象字面量
 // 但是也可以来自其他形式的资源,例如一个JSON的payload

 // 这样会提供很多益处:
 // 键字符串能够让代码有自我说明,形成一种文档,它很容易去读懂这个代码,因为代码告诉你了在每一个调用的地方是什么参数

 // 实参可以以任意顺序排列

 // 在以后新的参数添加进来而不会打破已存在的代码

 // 淘汰的参数可以忽略

 // 参数最通常的使用方式是初始化一个私有的属性
 // 我可以以这样的方式来做
 function my_little_constructor(spec) {
     let {
         name,mana_cost,colors,type,supertypes,types,subtypes,text,
         flavor,power,toughness,loyalty,timeshifted,hand,life
     } = spec;
 }
 // 这个创建和初始化了15个私有变量使用了跟属性相同的名字
 // 如果spec不含有一个匹配的属性
 // 新的变量就以undefined初始化
 // 那样就给了我们能力以undefined来填充一个缺失的值

 /**
  * Composition
  */

// JavaScript很昂贵地强大,因为它能够以类风格的范式来写程序,虽然它不是一个类范式的语言
// JavaScript让我们可以更好地做某些事情
// 我们可以使用函数式构成方式来做事情
// 与其跟预期一样,我们可以从这从那得到一点点的好处
// 这个才是一个构造器的大体的形式

function my_little_constructor(spec) {
    let {member} = spec;// 伪代码,表示这里拿到spec中的参数
    const reuse = other_constructor(spec);// 伪代码,表示这里使用其他的构造器
    const method = function() {
        // It can use spec,member,reuse,method
    }
    // 伪代码,上面的内容为定义每个函数,这些个函数能够使用spec中的参数

    // 返回一个冰冻的填充方法的的对象
    return Object.freeze({
        method,
        goodness:reuse.goodness // 由于other_constructor也是返回的一个填充方法的对象,这里把他们罗列在这里,能够充分访问他们的状态和调用他们的行为
    });
}

// 你的构造器能够调用你需要的数量的其他的构造器来访问这些其他构造器提供的状态的管理和行为
// 我们甚至可以传一个的spec对象给它们.
// 当我们写我们的spec 参数的文档的时候,我列出了my_little_constructor需要的属性
// 还有其他构造器需要的属性

// 在一些情况下我们可以简单地添加一些我们获得的冰冻对象中的一些方法
// 其他情况下,我们有自己的新的方法能够调用这些获得的方法
// 这个代码复用的实现类似于继承,但是它不存在紧耦合
// 调用一个函数,这个函数是一个原始代码复用的模式
// 它依旧是最棒的

/**
 * size
 */

// 这个对象构造器的实现需要使用更多的内存,比使用prototype风格的实现
// 因为每一个实打实的对象都包含所有的方法在本体,而不是在原型链上面去寻找
// 因为一个原型对象包含一个装有方法原型对象的引用,这样的话,就节约了空间
// 这个对于内存的消耗的差异有没有意义?
// 没有意义,内存这部分的优化跟改善的性能来说不成比例
// 我们曾经计算内存用k,现在计算内存用g
// 它们的不同或者它们的优化基本属于一点点噪音而已,无关痛痒

// 这个内存消耗的差异可以通过模块的改进来减轻.在属性上强调事务性能够减少方法的个数,这个也是一种内聚的改进

// 类模型是一个尺寸适应所有模型
// 每一个对象必须是一个类的实例
// JavaScript让我们从这个限制中获得自由
// 不是所有的对象都需要这么硬

// 举个例子,我不认为points(点)必须是一个装有方法的硬对象
// 一个点只是2个或者3个数的容器
// 点被传到函数里面能够做投影或者插值后者任何我们可以用点来完成的事情
// 那样就能够更高产相比点的子类来给他们特定的操作(也就是说点是一个硬对象,它是通过构造函数new出来的,然后通过自己的行为来修改存在点里面的那2,3个数这种行为)来说
// 还是让函数做这个事情吧