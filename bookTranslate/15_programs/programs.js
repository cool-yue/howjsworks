/**
 * How Programs Work
 */

 // JavaScript是以源格式的形式被传去执行站点
 // JavaScript的首要工作是为网页增加交互性
 // 由于HTML是一个文本格式
 // 所以决定把插入到网页的JavaScript当做源文本
 // 这个确实很不寻常
 // 在大多数其他的程序中,传送给执行机器的都是每个语言特定的机器指令码
 // 或者以更适合传输的格式例如字节码指令流(byte-coded instruction stream)
 // 这个字节码会被喂给一个解释器或者代码生成器

 // 在执行站点的一个JavaScript引擎编译JavaScript源代码
 // 创造出机器码或者去解释代码,或者2个都搞
 // 这个使得JavaScript变成一个很便携的语言
 // 程序不依赖于底层的机器的结构
 // 一个单一版本的JavaScript程序能够在任何的JavaScript引擎上面使用,不管它下面是啥

 // JavaScript编译器能够快速并且很容易地查对一些重要的程序的安全属性
 // 它能够保证程序不会去计算内存地址或者程序跳到限制区或者违反了类型限制(type restriction)
 // Java意图对它的字节码验证器做一些类似的事情
 // 但是它没有那么快、那么容易或那么确定

 // JavaScript的一些语法特性让解析不必要的困难
 // 即使这样,JavaScript引擎还是能够编译,加载和发动比java能够通过.jar文件加载和发动的速度要快很多

 // JavaScript是以源为单位来下发.一个源单位通常是一个.js文件
 // 但是它也能够是从JSON对象中的一个源字符串,或者从数据库中的源文本,或者资源管理系统

 // 在旧时代的web浏览器,源单位是页面的一部分,像一个<script>标签里面的内容,或者一个行内事件控制器
 // 在下面的例子中,alert("Hi")是一个源单位(source unit)

 //<img src=hello.png onclick=alert("hi");>

 // 现在接受插入的JavaScript源单位到一个HTML页面中是一个坏的实践
 // 它是一个坏的设计是因为表现和行为并没有分开
 // 它有一个坏的性能是因为页面中的代码不能够被gzipped或者cached
 // 它有一个坏的安全是因为它允许所谓的XSS+(跨站脚本)
 // W3C的内容安全方针(content security policy)应该永久性禁止所有的行内资源的使用

 // 一个源单元(source unit)被当做一个没有参数的函数体来对待
 // 它被编译成一个函数然后调用
 // 从而它可以让函数对象被创建,甚至被调用(意思就是全局申明的函数,全局调用函数)

// 那个就是程序运行的终结.但是在JavaScript中，对于源单位注册来接收事件或者信息或者导出一个函数,这个函数被
// 其他的源单位会用到,这些对于JavaScript来说,属于很一个源程序很典型的运作方式
// JavaScript也不强制要求程序应该以这种方式来写
// 但是这是一种伟大的写程序的方式,JavaScript支持这种方式好过大多数语言

// 历史性记录:行内事件控制器工作稍微有点不同.源单位还是被当成一个函数体来对待
// 但是事件处理器函数这个创建的不会立即调用
// 它会被绑定到一个DOM节点上,然后在事件触发的时候它被调用

 /**
  * primordials
  * 原生的
  */
// 存在这么个对象和函数能够让每一个源单位中都可用
// 我们已经看到这些中的一些,比如Number,Math,Array,Object和String
// 还有很多,都是被ECMASCRIPT标准所提供
// 除此之外主环境(例如,浏览器,node.js)可能有更多
// 所有的这些东西都能够在你的源单位中的所有的函数中使用


/**
* global
*/

// 在古老的浏览器编程模型中,所有在一个函数外面申明的变量都会被添加到页面级作用域，也叫全局作用域(这个华而不实还是？)
// 那个作用域包含了变量window,存有page作用域的引用的self
// 所有的页面级作用域的变量对于那个页面上的所有源单位都是可见的

// 这是一个坏的事情.它鼓励了一种风格的编程,使用全局共享的变量
// 这个导致程序脆弱和充满bug
// 它会导致不可以医疗的错误,当2个独立的源单位碰巧使用了相同的变量名
// 并且它会导致严重的安全问题
// 它会加速导致XSS产生

// 全局变量是魔鬼
// 幸运的是,现在事情变得好多了


/**
* Module
*/

// 在函数外定义的变量,放在一个module scope中更好,这样这些变量只对这个源单位的所有函数可见
// 这是一个好的事情,因为它导致了健壮地设计,更好的安全性和更好的保护错误

// 和其他源单位合作现在就明确了,使用import和export语句
// 这些语句能够被用来创造更好的程序
// 他们也会被用来创造坏的程序,我专注于好的一面

// 通过exporting,一个模块正在创造一个到处的变量来给其他的模块
// 一个模块应该导出一个东西,典型的一个函数或者一个充满函数的对象
// 导出的东西可能会被多个其他的模块使用,所以freeze这个导出的内容,来防止意外或者交叉感染是个很好的主意
// 一个导出是一个接口,接口应该是简单而干净的

// 源单位的代码体只会执行一次,这就意味着所有的importers共享同样的输出
// 这可以成为一个问题,如果导出的东西是个状态化的并且每个导入的地方都期待导入的是崭新的且不被共享的
// 在那个情况下,导出一个创造崭新和不被共享的实例的工厂函数
// export语句不创造实例

//exprot语句看起来是这样:
export default exportation;

// 确实不幸运的是default单词把事情搞臭了
// exportation表达式是一个冰冻对象或者一个函数你准备输出的

// importing允许你的源单位从其他的源单位来接受一个函数或者对象
// 你选择那个你想接收到的新的变量的名字
// 同时你还要以双引号的包含一些类别的名字或者地址,你的系统能够通过这个定位到那个源单位的
// 字符串字面量形式来指定提供者
// 如果有必要的话,读取它,编译它,加载它,调用它,最后传送他的输出

// 你可以把import语句想成一个特殊的const语句,它拿到从其他地方初始化好的值

import name from string literal;

// 我推荐只用一个export,但是你可以按照需要用很多个import语句
// 把你的import放在文件的顶端,把你的export放在文件的底端

/**
* Cohesion and Coupling
*/

// 好的程序在微观层面依赖好的代码约定,这个帮助增加好代码和坏代码之间的视觉差距
// 从而错误可以很简单地定位到

// 好的程序在宏观层面上依赖于好的模块设计

// 好的模块设计有很强的内聚性,意思就是所有的元素都有关系,并且在一起工作来完成一个特定的事情
// 坏的模块设计有较差的内聚,经常从很差的组织和尝试做过于多的事情开始产生的
// JavaScript的函数能够非常强力因为我们可以传入一个函数来照料那些模块不应该关心的特定的细节

// 好的模块是松耦合的.你应该仅仅需要一个模块的的接口的有限的资料来使用它.你不需要关心它实现的细节
// 一个好的模块隐藏了它的实现.
// 一个有漏洞的模块就会怂恿紧耦合
// JavaScript提供了很多怂恿紧耦合的地方
// 相互依赖的模块就是紧耦合
// 那个就是接近于全局变量一样坏和华而不实

// 让你的模块接口简单和干净
// 最小化依赖
// 好的结构对于给予一个程序能够扩展变大而不会困惑的能力,这个是必要的
// 内聚和耦合引入2本非常不错的书:(应该买不到)

// 2本书都是在面向对象编程之前出来的让他们过时了并且几乎被遗忘了
// 但是他们书中关于强内聚和松耦合的教学依旧是正确和重要的