/**
 * How Numbers Works
 */

 // 电脑是操作数字的机器
 // 操作数字基本上是左右的电脑都可以做
 // 他们看起来好像处理得确实非常好
 // 我们可以把其他种类的信息映射成数字
 // 电脑现在虚拟化影响人类所有的行为

 // JavaScript的数字是基于真实数字的灵感
 // 但是它们又不是真正的数字
 // 很多我们的数学理解和直觉可以应用到javaScript的数字上
 // 但是不是全部或者不能持久性地应用
 // 为了写一个javaScript的好的程序,我们需要知道numbers是如何工作的

 // JavaScript有一个单一的数字类型叫number
 // 它是借用的IEEE standard for floating-point arithmetic(IEEE 754)
 // 最开始为Intel's iAPX-432处理器所开发的
 // 432包含了很多聪明的想法,太多了
 // 432的结构变得太复杂,导致不能够完成它的目标
 // 他们就失去了最好的想法,简单性的一些视野
 // 很多好的东西都是伴随着432而消亡的
 // 432的浮点(float-point)单元作为8087被挽回和被售卖
 // 一个帮助8086的数学的合作处理器(co-processor)
 // 它变成了在奔腾和AMD64芯片上的标准设备

 // JavaScript总是被批评仅仅只有1个数字类型,但是这个实际上是一个最强大的东西之一
 // 程序员会更高产,如果他们不必纠结浪费时间去从一些类似的数值类型的困惑中选择一个,而且还伴随着由于选择了错误的类型导致难以理解的执行失败的风险

 // 类型转换的错误避免了,由于int类型导致的溢出错误也避免了

 // JavaScript整数比Java的整数更可靠因为溢出不会发生

 // JavaScript 2147483647 + 1 // 2147483648 完全正确
 // Java 2147483647 + 1 // -2147483648 完全错误

 // 我们怎么样才能够对程序的正确性有信心,如果一个程序是基于一个number system,这个系统在任意时候可以导致非常大的错误而没有警告
 // int类型不能够防止错误,他们会导致错误

 // 在浮点(floating point)的背后的仅仅的一个简单的想法就是:用2个数表示一个数(换个说法,1个数描绘成2个数)
 // 第一个数(有时候称为coefficient(系数),significand(有效位),fraction,or mantissa)存着数字
 // 第二个数(称为exponent(幂指数))区分出10进制(或者2进制)的点应该在什么位置插入到第一个数中
 // 浮点的实现比较复杂,这个复杂来自于需要让有限个数的bit位的固定形式能够得到充分最大化的使用

 // JavaScript不需要整个IEEE754的标准,他用了java使用的ieee 754标准的子集的子集
 // JavaScript的number非常接近Java的double
 // 它是64位二进制浮点类型
 // 这个数包含1个符号位,11个指数位和53个系数位
 // 一些非常聪明的编码可以让这个64位里面体现65位的作用?

 // IEEE 754,像很多在它之前出现的浮点系统一样,选择一个以2为基数.
 // 第一个数会被切成2个部分,符号位和系数位,符号位被放在了64bit中的大部分的系数里面
 // 如果这个符号位是1,表示数是负数,系数被放在最低的那些bit位
 // 它能够正常得表示一个2进制范围的的分数
 0.5 <= significand < 1.0

 // 在那个形式,大部分的系数位总是1.由于那个位总是1,所以不需要存在数字中,这就是生成了一个福利位

 // 第二个数是幂指数,它填充了符号位和系数位中间的空挡,一个数字的值就是

 // sign * significand * (2 ** exponent)

 // 但是有还有其他的复杂东西在里面.指数是代表一个偏移度的整数
 // 这个就可以比较,假定number是一个64位的整数
 // 那样就可以提供了一个很大的性能收益,这个在50年前很重要
 // 指数也能够编码NaN和Infinity和低于正常值的值(一个特殊的格式代表非常小的数和0)

 /**
  * Zero
  */
 // 除了0就没有0了.在正确系统中,只有一个0.
 // IEEE 754标准有2个0,0和-0
 // JavaScript勇敢地努力在你面前尝试隐藏这个可恶的东西,而且几乎成功实现了
 // 你可以安全地不理睬-0的存在,除了这些案例


 (1/0) === (1/-0) //false
 Object.is(0,-0) //false

 // 我不推荐你用0来当除数,我也不推荐你使用Object.is()

 /**
  * Number literals
  */
// 有18437736874454810627不可变的数字对象(number object),内建到JavaScript
// 每一个对象独立地代表一个数
// 一个数字字面量创造了一个对最接近这个数字字面量的数字对象的引用
// 有些时,他是准确的,有时它的偏移达到像9.9792015476735990582818635651842e+291这么大的偏差

// 一个整形的数字字面量就是简单的一个十进制数字的序列
// 通过使用一个进制的前缀以不同的基地组成一个数字也是可行的
// 所有的这些字面量都创造一个2018的引用

// binary: 0b11111100010
// otcal: 0o3742
// decimal: 2018.00
// hexadecimal:0x7E2

// JavaScript允许进制指定字母能够大写,但是把一个大写字母O放到一个数字字面量中当然会引起迷惑

// 十进制的数字字面量应该包含一个十进制的点
// 非常大或者非常小的数可能用e来紧凑地表示,它的含义是乘以一个以10为底的指数
// 比如6.0221408e23就是6.02214083 * (10 ** 23)的缩写
// 然后6.626e-34是6.626 * (10 ** -34)的缩写

// Infinity是一个值代表所有的那些太大而不能被展示的数
// 不要把Infinity跟数学的无穷搞混了,数学里面它不是一个值,而是一种隐喻

// NaN是一个特殊的值,这个值代表不是数的值.NaN是Not a Number的意思
// 有一个困惑的是typeof操作符去操作NaN返回的是number

// NaN可以是一个失败的字符串转数字的结果,而不是一个异常或者程序停止,它们的结果是给一个NaN你
// 算数运算符创造一个NaN当NaN是它们的输入的时候

// 关于NaN最差的事情是NaN跟它自己不相等.这是一个JavaScript没有盖住的IEEE 754令人憎恨的东西
// 检测NaN的相等跟其余的所有的数字都不同
// 这个可能是一个危险的地方,当检测的时候
// 如果期望的值是NaN,检测永远会失败,甚至实际值就是NaN
// 检测一个值是否是NaN,用Number.isNaN(value)
// Number.isFinite(value),如果值是NaN,Infinity或者-Infinity,返回的都是false

/**
 * Number
 */
// Number构造器(不是number,这个首字母的大写N很关键)是一个函数可以创造一个numbers;
// Numbers在javaScript中是不可变的对象
// typeOf操作符返回"number"(首字母是小写)
// 你不应该使用new这个前缀来调用Number函数
// 它不会做你觉得应该做的事情

const good_example = Number("432");
const bad_example = new Number("432");
typeof good_example // "number";
typeof bad_example // "object";
good_example === bad_example //false

// Number同样也是一些常量的容器
// 常量可以提供数字如何工作的内部视角

// Number.epsilon差不多是2.220446049250313080847263336181640625e-16
// 它是最小的正数
// 当它跟1加的时候,创造的和大于1
// 添加任何小于Number.EPSILON到1都创造一个等于1的结果
// 这看起来非常的荒谬一个非0的数加上1得到1
// 这不是JavaScript的bug或者设计错误
// 所有的固定尺寸的浮点系统都有这样的怪异东西,包括IEEE 754
// 它是一个合理的妥协

// Number.MAX_SAFE_INTEGER差不多是9007199254740991或者差不多是9倍的千的5次幂（9 quadrillion）在现代的的"illion"习语中
// JavaScript没有一个或者不需要一个整形,因为它的数值类型能够精确表示所有的整形数直到Number.MAX_SAFE_INTEGER
// JavaScript有54bit的带符号的整形数在它的number类型中

// 1加上一个比Number.MAX_SAFE_INTEGER大的数跟一个0加上那个大数的结果是一样的.
// JavaScript具备准确的整形计算,如果计算的数,结果,中间结果都在-Number.MAX_SAFE_INTEGER和Number.MAX_SAFE_INTEGER之间
// 有了这个范围,普通情况下的计算都能够驾驭得了
// 结合律和拆开律都是有效的

// 如果在那个范围以外,事情就更混乱了
// 例如加法中的数字的顺序会影响最后的结果所以
// ((0.1 + 0.2) + 03) 创造了一个比 (0.1 + (0.2 + 0.3))要大的结果
// Number.isSafrInteger(number)返回true,如果数字在安全的范围中

// Number.isInteger(number)返回true,如果number是个(整数并且在安全的范围中)也(可以在安全范围外的数,可以不是整数,但是这个方法返回的是true)
// 所有的大于Number.MAX_SAFE_INTEGER的数都被考虑成整数,有些确实是对的,但是大部分是错的

// Number.MAX_VALUE存着JavaScript能够表示的最大的数差不多是Number.MAX_SAFE_INTEGER * 2 ** 971
// 1.7976931348623157e+308

// 这是一个1后面跟着308位.大多数都是没有实际意义,这些数能够提供15.9位有意义的数,后面的292位数是被2进制转化到10进制生成的画面(详细见书上)

// 在Number.MAX_VALUE上面增加任何的正安全数创造的和还是Number.MAX_VALUE
// 它就像如果一个程序生成了一个Number.MAX_VALUE的结果,然后程序就出错了
// 所有超过Number.MAX_VALUE的值都应该被怀疑.IEEE 754标准承诺潜在的可数范围,但是没有去关心这个
// 他更可能造成错误

// Number.MIN_VALUE是最小比0大的可以表示的数.它准确等于2 ** -1074

// 所有的正数比Number.MIN_VALUE小的就跟0没有区别
// 注意到Number.MIN_VALUE的系数只包含一个单一的bit位在系数位置的最低位
// 那些孤独的bit位创造了太多没有意义的东西

// Number.prototype是一个对象所有number是继承Number.prototype,它是一个包含一些方法的对象
// 不幸的是,没啥用

/**
 * Operators
 */

 // 前缀操作符

 // +
 // 转成number(to number)
 // +这个符号,前缀操作符把它的操作数转成一个数字,如果转化失败,它就生成一个NaN.Number函数更好,因为它更明确

 // -
 // 负
 // -减号符号,前缀操作符改变了它的操作数的符号。在JavaScript中的数字字面量是没有符号的,像一个表达式(-1),这个减号是一个操作符,而不是数字字面量的一部分

 // typeof
 // 类型是
 // 如果操作数是一个数,它会创造一个字符串"string",甚至操作是NaN也会

 // 后缀操作符

 // +
 // 加(addition)
 // 不幸的是,+操作符也会被字符串来用作拼接,这个过度使用创造了一个危险.如果有一个操作数是字符串,那么它会把另外一个操作数转化成字符串然后拼接它们
 // 不幸的是,没有其他的方式来做加法了,所以你必须要小心谨慎.Number函数在确保操作数当做+符号的后缀运算符(加法)时候能够起到作用,能够让这个符号起到加法的作用

 // -
 // 减法(subtraction)

 // *
 // 乘法(multiplication)

 // /
 // 除
 // 这不是一个整数的除法,这不是一个整除,如果你把2个整数进行除操作,你可能会得到一个分数的结果:5/2生成2.5而不是2

 // %
 // 取余(remainder)
 // JavaScript没有驱魔的操作符,取而代之的是一个取余操作符,我认为取模更有用,取余的结果是拿到它的符号