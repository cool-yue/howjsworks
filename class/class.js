/**
 * how Class free works
 */

 // 在面向对象编程中的一个关键的理解是一个程序的各个部分之间交互和通信的模型
 // 想象一个方法名和它的参数作为一条信息
 // 调用方法传送信息到一个对象
 // 当它接收到特定信息时,每个信息都触发自己的行为
 // 发送者角色接受者知道用那个信息来做什么

 // 从这里面掉出的一个东西之一就是多态
 // 每一个对象能够识别一个特定的信息就有资格接受那个信息
 // 下一步发生什么是依赖于对象的具体实现
 // 这是一个非常牛逼的想法

 // 不幸的是我们被继承把注意力带偏了
 // 继承是一个牛逼的代码复用的机制
 // 代码复用很重要,因为它让我们能够减少开发一个程序的工作量
 // 继承创建了一个同样被预料到的观点
 // 我们可以说一些对象或者对象的类和一些其他的对象或者对象的类一样除了一些重要的不同点
 // 这个工作得很好当事情简单的时候
 // 我们应该记住现代面向对象是从smallTalk开始的,这是一个为孩子设计的
 // 当事情变得复杂时,继承就变得有问题了
 // 继承导致了类的紧耦合,一个类里面的改变能够导致依赖它的类失败
 // 类更倾向于是一个失败的模块

 // 我们同样也看到很多注意力都放在了属性上,而不是放在对象上
 // 存在过于强调每个单个属性的getter和setter方法
 // 或者在最坏的设计中,属性是公共的并且能够不被对象察觉地被修改
 // 尝试好的设计是可行的,属性被隐藏,方法处理事务,不仅仅是属性的修改
 // 但是它并不是经常发生

 // 还有一个就是过分依赖于types(类型),类型是FORTRAN的一个特性和
 // 类型对于编译器的作者来说很便利的后来出现的语言
 // 从那时起,关于类型的神话开始越来越兴起
 // 过分地宣称类型能够保护程序不出错
 // 尽管投身于类型,然而错误仍然每天都出现

 // 类型获取信任,并且值得这个信任,通过编译器在早期就能够发现错误
 // 越早发现一个bug,开销就越小
 // 但是如果程序以正确的方式测试过
 // 所有这些bug都能够很快找到
 // 所以通过类型识别出来的bug都是没啥价值的bug

 // 从来不会给类型没找出bug来责备它,昂贵的bug
 // 通过需要规避类型的时候,类型导致的出现错误,也不会被追究
 // 类型能够诱导我们接受含义隐晦,杂乱的,没有把握的编程实践方式

 // 类型就像瘦身餐.这种配餐对于减重能够得到信任
 // 从来不会把体重又回来了甚至增加了归咎于瘦身餐上
 // 从来不会把它引起的健康问题和痛苦归咎于瘦身餐上
 // 瘦身餐给了我们信心,我们吃不健康的食物,我们也可以获得一个健康的体重

 // 当我们继续创造更多bug和遗产代码时候,类的继承会让我们想到我们在写一个好的程序
 // 如果你忽略这些消极的东西,类型感觉是一个大胜利
 // 有益的地方确实有,但是如果你系统性地看类型,开销超过了收益

 /**
  * constructor
  */

  // 在13章(generator)中,我们以工厂的形式来实现功能(函数返回函数)
  // 我们现在可以跟constructor(函数返回包含函数的对象)相似的是东西
  // 我们以创造一个counter_constuctor,这个函数根counter generator相似,他有2个方法,up和down

  function counter_constructor() {
      let counter = 0;
      function up() {
          counter += 1;
          return counter;
      }
      function down() {
          counter -= 1;
          return counter;
      }

      return Object.freeze({
          up,
          down
      })
  }

// 返回的对象被冰冻了.
// 对象不会被破坏或者损坏
// 对象是有状态的
// counter变量是对象的私有属性
// 它只能通过方法来访问
// 我们不必非要用this

// 这个很重要.对象的接口是它的方法
// 仅仅是它的方法
// 对象有一个非常硬壳子
// 这个给了我们最好的封装
// 没有直接访问数据的权利,这是一个好的模块设计

// 一个构造器(constructor)是一个返回一个对象的函数
// 构造器的参数和变量变成了对象的私有属性
// 没有共有数据属性
// 构造器的内部函数变成了对象的方法
// 它们掩盖了私有属性
// 放入了冰冻对象的方法是公共方法

// 方法应该实现事务性.例如,假如我们有一个person对象
// 我们可能想要支持改变person的地址信息
// 我们不应该有一个分离的set函数来改变address中的每个单独项目
// 我们应该有一个单个方法接受一个可以描述所有的需要修改的address的部分的对象字面量

// 在javaScript中一个很聪明的想法是对象字面量这个东西
// 它是一个很愉快同时也是很昂贵的聚集数据的语法
// 通过创造消费和生产数据对象的方法
// 我们能够减少方法的数量,增加对象的集成度

// 所以我们有2个类型的对象:

// 硬编码对象只包含方法.这些对象保护着闭包里面的数据的完整
// 他们给我们多态性和封装性

// 软数据对象只包含数据,这些对象没有行为
// 他们仅仅是能够被函数操作的非常方便的集合

// OOP的一个观点起始于在一个COBOL记录中添加处理过程(adding of procedures)来提供行为能力
// 我认为方法和数据属性的结合是一个重要的进步
// 但是它也不是最后一步

// 你应该包含一个toJSON方法如果hard object需要被stringify
// 除此之外,JSON.stringify把它dangchen一个空对象来看,不管它的方法和隐藏在里面的数据

// 也就是函数并不会被打印出来
//aaa = {getA:function() {return this.a}}
//JSON.stringify(aaa)
//"{}"
