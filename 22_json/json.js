/**
 * How JSON Works
 */

 // 在这里,第一波文字,我告诉你世界上最喜欢的交互格式的数据的最初真实故事

 /**
  * Discovery
  */

  // JSON是在2001年在Chip Morningstar的房子后面的一个棚子里面被发现的
  // Chip和我已经开始了一个公司来为一个单页的web应用开发一个平台
  // 我们的分工是,使用一个好的JavaScript库(Douglas crockford写)和一个性能好并且可伸缩的会话服务器(Chip写)
  // 这可以创建出一个web页面跟安装程序一样好,或者更好,因为我们的平台也支持多用户合作
  // 这是当时web还不能够胜任的

  // 我对Chip写的session服务器印象深刻.他在多年里重实现了这个服务器很多次
  // 最近的迭代叫做Elko.elkoserver.org

  // Elko的唯一做错的事情是它是以Java写的
  // 我的梦现是有一天某个人能够付钱要chip再做一次,而这一次用JavaScript
  // 使用Node.js,那样就可以把我们推到正确的方式上面
  // 我们可以有更好的安全,更好的伸缩性,并且支持一个更广的应用

  // 回到这个棚子,我们需要一个方式来在浏览器和服务器之间发送信息
  // 在那个时候,软件行业完全投入了XML的使用中
  // 巨人像是微软,IBM,Oracle,Sun,HP还有其他公司决定下一代的软件准备在XML上面构建,它们的外围组织和客户纷纷效仿

  // 我们想要在2个不同的语言写的程序之间交互数据
  // 我们看了XML,觉得它跟我们想要解决的问题非常不适
  // 使用XML的模式是首先你发送一个query到服务器,服务器返回一个XML文档
  // 然后拿到数据,你再在这个XML文档中再来query
  // 为什么服务器不能够发送一个数据我们的程序可以立即使用呢?
  // 我们的数据根本不像一个文档

  // 在那个时候,有很多改进的XML的变体和替代品可用
  // 但是没有一个具有牵引力(traction),能够真正解决痛点而具备很强的影响力
  // 我们想过自己去弄一个出来
  // 然后我自己有个想法
  // 我们可以使用JavaScript对象字面量,它们已经内建进JavaScript了
  // 所以在JavaScript这边非常的方便
  // 我所需要剩余的工作就是在Java端去解析,显然这不是很难
  // 它显然比XML好解析,也比xml更高效

  // 我们想要我们的平台跟微软的IE和网景浏览器工作
  // 那样非常的困难,因为他们各自都在创造他们自己的特性
  // 没有什么共同点
  // 微软添加一个XMLHttpRequest方法,那个可以用来跟服务器通信
  // 不幸的是,网景没有像这样的东西,所以我们不能够用它

  // 两个浏览器都有JavaScript并且都有<frameset>这个标签
  // 所以我们把这些用在一起来锻造一个通信通道
  // 这是第一个传送到浏览器的JSON信息
 ` <HTML>
      <head>
          <script>
            document.domain = "fudco.com"
            parent.session.receive({to:"session",do:"test",test:"hello world"})
          </script>
      </head>
  </HTML>`

  // 一个页面包含一个不可见的能够导航的<frame>
  // 在影藏的frame上面做一个POST请求发送信息到服务器
  // 服务器返回通过传送一个文档,这个文档包含一个调用mian frame当中session对象中的receive方法的脚本
  // 我们必须改变document.domain来保证内部的frame之间的通信
  // JavaScript的编译器来解析这个信息

  // 我希望我能够告诉你第一个消息能够成功地被传送,但是它失败了
  // 它失败是因为ES3的恶心的保留字策略
  // 那个时候的保留字有:
  // abstract boolean break byte case catch char class const continue debugger
  // default delete do double else enum export extends false final finally float for
  // function goto if implements import in instanceof int interface long native new
  // null package private protected public return short static super switch
  // synchronized this throw throws transient true try typeof var void volatile while with

  // ES3保留字政策这上面规定说：这些保留字不能够用作变量名或者参数名或者点号位置的属性名或者在对象字面量中的属性名
  // 这个消息含有一个do属性,所以脚本有一个语法错误然后停止执行了

  // 我非常高兴地报告这个在ES5的时候修正了
  // 保留字列表变短了,并且在属性名上面的限制解除了
  // 但是在2001年我们必须在do上面加上引号来让它工作
  // 如果非要在字面量中使用保留字的属性,那就需要用引号括起来
  // 比如在 a = {function:1} //SyntaxError: import is a reserved identifier
  // 而 a = {"function":1} // ok


  // chip把保留字列表放入它的编码器中
  // 然后我们就没有什么问题了

  // 我们发现一个字符串包含一个字符序列"</"会导致失败
  // 那是因为浏览器假定了这个是script标签的结束,所以JavaScript就没有接收到完整的payload
  // 导致一个语法错误,我们的工作是转义这个斜杠.浏览器会很乐意处理<\/

  // 我把它称呼为JSML(rhymes with dismal),后来我们发现有些Java的东西用了这个首字母,所以我们很快地换了一个名字:JSON

  // JSON在JavaScrip和Java之间通信确实工作得很好,我们也用它来做服务期间的通信
  // 我们创建了第一个JSON数据库

  /**
   * Standardization
   */
  // 我们有过一段为我们客户卖JSON的概念的艰难时期
  // 他们告诉我们他们不会用,因为他们已经完全采用了XML
  // 他们告诉我们他们不会使用它,因为它不是一个标准
  // 我告诉他们它是一个标准
  // 它是一个ECMA-262的子集
  // 他们告诉我们那不是标准
  // 所以我决定变成一个标准实体

  // 我买了json.org的域名,让它去完成标注化JSON的工作
  // 直到那个时候,JSON就像一个绅士的约定一样存在,在我,chip,JavaScript之间.
  // 在制定标准的时候,我不得不做些决定
  // 我的指导原则是保持一个文本化的,最小化的,和一个JavaScript的子集

  // 最小原则非常的重要
  // 标准需要简单和完整
  // 我们遵循的东西越少,我们就能够更简单地互操作
  // JavaScript的子集原则让我很高效而不用添加一大堆可爱又没必要的特性进去

  // JavaScript允许字符串能够被'(单引号)和"(双引号)引起来
  // 最小化原则告诉我,我们只需要1个

  // 我决定在属性名周围需要有引号.我不想把ES3的保留字清单放进标准
  // 因为它看起来确实很蠢,不可避免的问题是为什么?答案是因为是JavaScript
  // 我们正在尝试着说服人们使用JavaScript开发他们的程序
  // 所以我不想要JSON标准上面闪着JavaScript那些不好方面的光
  // 如果我们把所有的名字都用引号引起来,然后就没有这个问题了
  // 它同样可以简化说明文档因为 什么是一个字母?因为国际化,变成了一个非常困难的问题
  // 所有这些问题都避免了,一个属性可以是任意的字符串
  // 简单！
  // 这个就让JSON更Python类,这个我想可以帮助驱动别人采纳这个

  // 我增加了注释因为它们被JavaScript的子集允许并且我认为这样很聪明
  // 然后我看到一些早起的采纳者把解析指令放进注释中
  // 那样会破坏最重要的意图-互用性

  // 随着更多的JSON的译码器为其他语言所开发,我意识到一半的工作都是开发处理注释的JSON的解析器
  // 这不是因为注释很复杂,而是因为除了注释剩下的JSON很简单
  // 注释减慢了采纳的速度

  // 然后我被YAML接洽了.JSON碰巧跟YAML的子集很相似
  // 如果2个都做些改变,JSON能够变成一个正确的子集
  // 争论中的一点就是注释

  // JSON确实通过网络连接着用不同语言写的程序
  // 注释经常被忽略了,当他们使用时,这些注释降低了网络传输的效能
  // 注释是多余和有吸引力的麻烦事(attractive nuisance),所以我把它们移除了

  // 如果你确实需要注释,有很多方式去做它
  // 仅仅让你的内容文本通过一个压缩工具类似jsmin
  // 不幸的是,这个解决方案不适合缺少能力去写个pipe脚本的程序员

  // 其他的解决方案是把注释正式化了并且把它们放进了JSON的结构里面
  // 如果注释是特别重要,它们被给个名字,这样它们才能够被正确的保留和处理
  
  // 我的让JSON变成JavaScript的子集的目标失败了
  // Unicode有一对不可见的控制字符
  // PS,段落分隔符
  // LS,行分隔符
  // 这2个是为了老派单词处理系统的好处
  // JavaScript把它们对待成行结束字符
  // 就像CR和LF
  // 我弄掉了PS和LS,所以JSON允许它们在字符串中
  // 幸运的是,PS和LS很少用.我没有意识到从这里导致的任何问题
  // ES5添加了一个内建的JSON解析器,这个解析器处理了PS和LS,修复了不一致性

  // 存在一些字符在Unicode中,但是Unicode认为不是字符
  // 有一些Unicode的狂热分子坚持JSON不应该允许magritte字符
  // JSON不在意.JSON是一个媒介而不是一个强制实施者.
  // 这个由于接受者来决定什么字符不算有效字符
  // JSON不能够保证每个东西对每个接受者都有意义
  // 如果一个发送者和接受者能够有一个达成共识
  // 那个共识就能够表现在JSON中

  // 我想要让JSON独立出IEEE 754.Java和JavaScript都用IEEE 754二进制浮点数
  // 但是JSON不关心
  // JSON能够能够让语言之间使用不一样的数字表示进行交互
  // 所以二进制浮点数的语言能够跟BCD语言交互
  // 大十进制浮点数语言能够跟那些古怪内部以3位数字打包进10bit里面的表示数字方法的语言进行交互
  // JSON能够从IEEE754的过时中生存下来

  // 我把Infinity和NaN给剔除了,因为它们在data中的表示预示着错误
  // 我们不应该把坏的数据放在线缆中传输
  // 我们不应该传播坏数据
  // 那是非常不好的实践

  // 我引入了e和E作为十进制的指数的标志,这是违反了最小原则的,我应该移除E,我也应该移除e后面的+号

  // 我引入了null,因为电脑科学家好像喜欢这个.JSON不会把null贴上什么含义
  // 那些都是JSON的用户决定的
  // JSON不会制定任何的行为,它只指定了一种格式,一个数据的简单的语法

  // 我创造一个网页以3种方式来描述JSON:
  // A McKeeman Form语法
  // (railroad diagrams)铁路图
  // 比较通俗的英语
  // 我希望一个读者能够理解这其中的至少一个

  // 我没有获得一个JSON的商标或者logo
  // 我没有把一个版权提示放在页面上
  // 我想要让JSON标准尽量自由尽量没有负担
  // 我不想从JSON中赚钱,我只是想被允许使用它

  // 我开始得到了各种请求在各种语言中的编码器中添加我写的json.org网站的链接
  // 几乎他们所有的都是开放和免费的
  // 我也接受了网站翻译的捐款
  // JSON的简单性的益处之一是那个页面比较容易翻译

  // 在2006,我为IETF写没有正式发布的RFC 4627,为JSON申请一个MIME的type类型
  // 我希望为你们弄到的是text/json
  // 但是它们能给我们最好的是application/json,这个确实让人失望

  // 随着JSON的成功,我认为IETF应该让json作为第一类媒体类型
  // 这样人们就可以注册json/geo和json/money这种MIME类型

  // 在2013年,我写ECMA-404,这个被ISO作为ISO/IEC 21778所采纳了
  // JSON在那时已经变成很重要以至其他的标准都要引用它,他们相比我的网站需要一个更正式的引用

  /**
   * Why JSON Works
   */

   // JSON是为了让以不同语言写的程序之间可以高效的工作
   // 有一个非常困难的问题是在一个语言中表示一个值或者数据的时候的细节会非常的复杂
   // 所以,我在设计JSON的实现时候把注意力放在了它们的共性上

   // 语言在它们表示一个数的时候是很天南地北的差别
   // 但是有一个共同点是一个数可以被一个10进制数(可能里面还有小数点)的字符串和一个十进制的指数的权值（10 ** X）来表示
   // 一些语言有一个整数型,一些语言(比如javaScript)没有。
   // JSON说:我们可以做一个对所有情况都有意义的字符串形式的数

   // 语言对于字符串和字符集都有不一样的思路
   // 一个语言可能有一个内部的呈现方式,比如UTF-16(比如JavaScript)或UTF-32或者UTF-8或者ASCII或者Half ASCII或者EBCDIC
   // JSON不管这些
   // 我们做的最有意义就是从网络那边获得的一个字符串的字符能够把它们转化成合理的本地表示

   // 所有的语言都有一些值的线性序列的数据结构,有一个JSON的反编译器的帮助
   // 一系列的被放在中括号中,然后以逗号分隔的的值就有意义了
   // 然后可以把它们转化成本地合理的表示
   // 基于0起始的语言能够和基于1起始的语言交互

   // 大多数语言都有一类数据结构,可以把名字和值联系在一起
   // 这里面的实现细节可以非常不同,但是所有的语言,有了一个JSON反编译器的帮助
   // 能够把一系列有名字的值(键值对)放在大括号中以逗号分隔的这种形式就有意义了

   // 那就足够了.通过找到所有编程语言的交叉点,以这所有编程语言中的语言写的就能够互相交互数据
   // 批评者说它不能工作
   // 然而它还是能够工作！
   
   // 下面补充一下,为何可以工作的原理:
   // 首先明确的是所有的JSON文本里面的都是以Unicode的code point来决定的,这个是约定好的,所以前端和后端
   // 需要针对unicode来进行对字符进行有意义表示,比如转码
   // 有了这个大前提,由于每个语言都有类似数组和对象的数据结构
   // java/ array||arrayList / 实例对象
   // javaSCript/ array / obejct
   // python/array/ dictionary
   // 第一个类型,我们遵循中括号然后以逗号隔开每个值
   // 第二个类型,我们准许大括号然后里面的name要是字符串并且使用双引号(因为是最小规则),然后值可以不用引号
   // 具体也可以看ECMA-404的pdf！这个文件就在文件夹里！

   /**
    * Influences
    */
   
    // 由于我的其他2个语言的经验,我能够察觉到对象字面量的便携性
    // LISP语言有一个文本表示的方式,叫s-expressions,这个既可以用在程序中也能用在data中
    // Rebol语言也用同样的文本表示程序和数据,但是Rebol有更丰富的语法
    // 在Rebol中用那种文本表示的方式来序列化数据来传输非常地自然一气呵成
    // 我把同样的想法用在了JavaScript

    // 我不是第一个使用JavaScript作为数据编码的人
    // 这个被很多人都独自探索出来了,第一次早在1996年
    // 我是那个把这个促成一种标准的人

    // 3个语言,JavaScript,Python和Newtonscript,都是在同一时间被设计的
    // 所有的都有相似的语法来创建数据结构
    // Next OpenStep系统的Property Lists(属性列表)以相似的记号创造出来有点早了
    // Property Lists是一种文件,把数据序列化写入一个文件中,这个通常用来存用户的设定
    // 比如Java里面的.pro文件

    // 在我们后XML时代的舒适区里,JSON看起来是不可避免的.但是它还在逐渐展露头角,还远没有确定

    /**
     * The JSON Object
     */

     // JavaScript支持JSON对象中的2个函数.
     // 这2个函数被称为parse和stringify
     // 这个完全是我的错
     // 我选择parse遵循了Date函数的坏的例子,这个我们已经看到了深度的缺陷
     // 我选择Stringify因为toString好像不正确
     // 我应该称呼函数为decode和encode

     JSON.parse(text,reviver)

     // parse函数接受一个JSON字符串并且把它解码成JavaScript的data
     // 可选的reviver函数能够做转换
     // 它被喂一个键和值,然后返回对于那个键你想要的值

     // 例如,你可以创造一个reviver把date字符串转化成data对象
     // 如果一个key是以_date结尾或者值是一个以ISO日期形式的字符换
     // 然后根据那个值来生成一个日期对象来替换这个值
     // JSON是正经地不包括date类型的值得
     // 但是date能够很方便的编码成字符串然后反过来又转化成date对象

     const rx_iso_date = /^\d{4}-\d{2}-\d{2}(?:T\d{2}:\d{2}:\d{2}(?:\.\d*)? Z)?$/;

     const text = JOSN.parse(text,function(key,value) {
      return (
          typeof value === "string" && (
              key.endsWith("_date")
              || rx_iso_date.match(value)
          )
          ? new Date(value)
          : value
      );
    });

     // 下一个函数

     JSON.stringify(value,replacer,space);

     // stringify函数接受一个值并且把这个值编码成一个JSON文本
     // 可以选的replacer函数能够做转换
     // 它会被喂一个键和一个值,并且它返回那个键想要的值

     // 例如,如果我们想要自动的把Date对象转化为ISO Strings,我们可能
     // 提供一个replacer函数.replacer函数的结果会被传入到JSON.stringify中
     // 并且那个结果会被包含在文本中

     const json_text = JSON.stringify(my_little_object,function (key,value) {
       return (
         value instanceof Date
         ? value.toISOString()
         : value
       );
     });

     //(后来被证明我们不需要做这个,因为Date.prototype.toJSON已经能够自动实现了)

     // repalcer参数也能够是一个字符串数组,只有在这个数组的属性名最后才能被放入JSON中
     // 这是一个白名单,我们希望过滤那些我们不感兴趣的属性
     // 这个应该是一个单独的参数,而不是要占用过负荷replacer函数的位置

     // JSON格式允许whitespace在JSON文本中来让可读性更好
     // 默认情况下,JSON.stringify不会添加whitespace所以文本就能够更好的去传输
     // 如果space参数使用了,那样换行和缩进就会被传输
     // 如果space参数用到了,然后换行和缩进就会被插入
     // 正确的space参数的值是4
     // 显然我应该让这个参数变成一个bool值

     toJSON()

     // 任何一个对象都允许有一个toJSON方法,它被叫做JSON.stringify当对象被字符串化的时候
     // 这就是为什么没有类的对象可以有一个JSON的表示
     // 一个没有类的对象,只包含函数,会被正常地字符串化成一个空对象
     // 如果有一个toJSON方法,它会把这个对象字符串化成toJSON方法返回的值

     // Date对象集成了toJSON方法,这个方法把data对象编码成了ISO字符串

     /**
      * Security Implication
      */
     // JSON的第一批使用者使用JavaScript的eval函数(或者等效的函数)来解码JSON文本
     // 这个会有从eval函数继承的危险在里面,但是在这种情况下
     // 潜在的危险的文本来自同提供HTML和所有脚本的同一个服务器
     // 所以它的安全性相比整个web来说,没有那么糟糕

     // 当从另外一个服务器以Script标签来加载JSON的这种实践方式流行后,这个就改变了
     // 脚本被eval函数计算,不能够保证任何一种payload都是好的JSON并且不是XSS攻击
     // 这是方便但不负责
     
     //JSON文本永远不应该被拼接因为一段神奇的字符串能够包含引号和斜杠字符,这个字符会导致文本的错误解析
     // JSON文本应该永远是被JSON.stringify来创造或者类似的工具
     // 这样才不会引入一些迷惑

     // 这就是为什么toJSON的结果和replacer函数的结果都会被JSON.stringify来处理
     // 如果这些函数的返回值被作为插入文本的值,这些函数就会加剧误导了最终形成的字符串导致的困惑
     // 如果字符串没有以同样的字符开始和结束这样比较好,但它们是这样的
     // 这样就给了我们另外一个要聪明地去编码的理由

     /**
      * Mckeeman Form
      */
     // 详细见书
     // 后面再看

     /**
      * JSON grammer
      */
     // 这个是基于上面的风格来形成的文档
     // 详细见书
     // 后面再看
     
     /**
      * Advice to Data interchange Standard Designers
      */
     //对于交互数据的建议
     // 这里详细见书,不单独翻译了,大致的几个标题是
     // 0.请不要破坏JSON
     // 1.让它有意义地更好
     // 2.给一个好的名字