/**
 * How Booleans Work
 */

 // boolean这个类型,是随George Boole这个人的名字而命名字的
 // 一个英国的数学家,发明了代数逻辑
 // claude shannon(香农)采纳了Boole的系统来设计数字电路
 // 那就是为什么我们称计算机为电路逻辑

 // boolean的类型仅仅只包含2个值,true和false
 // Boolean值经常是被比较符所生成的
 // 被逻辑操作符来操作
 // 被三元运算符,if,do,for和while语句来消费

 // typeof 操作符返回"boolean"当它的操作数是true或者false

 // 关系运算符
 // === 等于
 // !== 不等于
 // < 小于
 // <= 小于等于
 // > 大于
 // >= 大于等于

 // 深度不幸的是等于的操作符是===而不是=
 // 更不幸的是不相等操作符是!==而不是≠
 // 所有的这些操作符确实做了太多你所想不到的
 // 也有很多没有道理的东西,下面展示

 undefined < null // false
 undefined > null // false
 undefined === null // false
 NaN === NaN // false
 NaN !== NaN // true
 "11" < "2" // true
 "2" < 5 // true
 5 < "11" // true

 // === 和 !== 总的来说做了正确的事情,除了2个操作数都是NaN
 // === 和 !== 能够用来决定一个值是否是null或者undefined或者任何的值除了NaN
 // 测试一个值是否是NaN,经常使用Number.isNaN(x);

 // ===不能被用来检验一个循环的完成,除非指引变量(induction variable)是在安全整形数范围
 // 即便是这样,使用>=来检验会更安全

 // <和<=,>和>=总体来说做了正确的事情当2个操作数都是字符串或者2个操作数都是数
 // 其余情况大多时候是没有道理的结果.
 // 请避免在比较的时候两边使用不同的类型
 // javascript并没有阻止两边都是混合类型,所以你必须要带来你自己的一套准则

 // JavaScript也有一些比较操作符可靠性更差
 // 我推荐永远不要使用==和!=
 // 在比较值钱,它们会做类型强制转换
 // 这样就很容易产生"假的真"或者"真的假"
 // 总是使用 === 和 !==,记住永远!

 /**
  * boolish
  */
 // JavaScript有一个可爱的布尔类型但是却没有好好得使用
 // 一个程序的这些地方,boolean做得最好

 // if语句条件的位置
 // while语句条件的位置
 // for语句条件的位置
 // do语句条件的位置
 // !操作符的操作数
 // && 操作符的操作数
 // || 操作符的操作数
 // 三元运算符?的操作数
 // Array的方法,filter,find,findIndex(为什么),indexOf(为什么)其中的传入的函数参数的返回值

 // 在一个设计得很好的语言中,仅仅只有boolean值才能够在这些位置,JavaScript允许所有类型的值在这些位置
 // 所有的值都是boolish type的成员
 // 所有的值在boolish type中可以是truthy或者falsy

 // falsy的值有:false,null,undefined,"",0,NaN

 // 所有其他值都是truthy,包括空对象,空数组还有一些看起来像false的字符串比如"false"和"0",它们都是truthy

 // falsy values经常表现像false,但是大多数时候不是,严格来说,false;
 // truthy values经常表现像true,但是大多数都不是true
// 这种boolish的表现是一个错误,它不是一个突发事故,而是有意为之来允许让C语言的惯用方式使用

// C是一个不充分类型的语言，它使用一个单一的值表示0,它使用一个单一的值来表示0,FALSE,NULL,string的结束还有其他东西
// 它们对于c来说都是一样的,所以在if语句的条件位置,C在寻找检查表达式是否是0
// 有一个c编程的风格语言充分利用这个,来使得条件变得简洁

// JavaScript有一个合理的boolean值,但是boolish这个机制把大部分的价值都扔掉了
// 一个条件应该只有true或者false
// 其他值应该是error
// 理应是一个编译时错误
// 这个在JavaScript不是事,条件表达式能够跟c里面一样简洁和晦涩难懂
// 值恰好掉进了条件位置不会被标记成错误
// 相反,他们能够把程序往没有预测到的方向推送
// Java语言需要条件必须是boolean，并且消除了一类错误,我希望javascript也做到这个

// 我推荐你写程序,就好像javaScript设计对的那种风格来写
// 在所有的条件里面都用boolean,如果你写一个风格更好的语言,你就会写出更好的程序

/**
 * Logical Operators
 */

 // 逻辑操作符也从属于boolish这范畴

 // !,逻辑非,如果操作数是truthy那么结果是false,如果是falsy就是true
 // &&,逻辑与,如果第一个操作数是falsy,那么结果就是第一个操作数,第二个操作数不会去计算了,如果第一个操作数是truthy,那么结果就是第二个操作数
 // ||,逻辑或,如果第一个操作数是truthy结果就是的第一个操作数,第二个不会计算,如果的哥操作数是falsy,结果就是第二个操作数

 /**
  * Not!
  */

  // 逻辑表达式变得复杂.有一些正式的转换能够简化他们
  // 不幸的是,boolish范畴的值和NaN能够导致正常转化产生错误

  // 在一个逻辑系统中,经常使用双感叹来简化双重否定,是很明智的
  !!p === p
  // 上面这条语句仅仅是在p是一个boolean值的时候才成立
  // 如果p是任何其他的类型,!!p === Boolean(p);
  // 而不是等于p

  // 有些比较运算符有些对立面的,所以<跟>=是对立面,>和<=是对立面,所以它应该被简单化
  //!(a<b)要写成 a >= b因为

  // !(a === b) === (a !== b)
  // !(a <= b) === (a > b)
  // !(a > b) === (a <= b)
  // !(a >= b) === (a < b)

  // 如果a或者b有一个是NaN,那么代码的转化就会失败,这是因为任何数字和NaN比较创造了一个false
  // 不管你的操作符号

  7 < NaN // false
  NaN < 7 // false
  !( 7 < NaN) === 7 >= NaN // false

  // 它可能说得通.如果NaN是比所有其他数都小,或者一个数和NaN比较产生一个异常
  // JavaScript选择没有道理的东西来实现
  // 唯一有意义的是Number.isNaN(NaN)
  // 在所有的上下文中避免NaN


  // De Morgan定理能够对我们对于逻辑表达式上面有帮助
  // 我经常使用它们

  !(p && q) == !p || !q
  !(p || q) == !p && !q

  // 这个定理是正确的只要p和q不是没有道理的boolish
  // boolish应该避免使用
  // 用boolean!

  /**
   * conclusion
   */

   // Number.isNaN // 判断NaN
   // 避免任何上下文中存在NaN
   // 始终使用 === 和 !==
   // >= > < <= 避免2边的操作的类型不同



