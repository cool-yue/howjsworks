/**
 * How Exceptions Works
 */

 // 程序员是乐观主义者.经常都会有一个隐性地假设在我们的程序中,这个假设是所有东西都能够正确执行
 // 但是就算是一个乐观主义者,也知道有时候事情会出错

// 有一个可能性,我们以一个没想到的方式来调用一个函数可能会失败.
// 这在使用第三方代码库的时候尤为顾虑
// 耦合的某种层面来讲就是失败的模式(one of the dimenstions of coupling is failure modes)
// 当失败的时候,应该发生什么?
// 整个代码是不是都失败?
// 我们是不是应该再次调用那个函数并且希望一个更好的输出呢?
// 错误的结果如何来进行交互?

// 这个问题的最受欢迎的解决方式是exception handling(后面称呼为异常控制)
// 这个机制让我们解放自我去更乐观地写代码
// 我们不必为在每一个返回值中的难以理解的错误代码做检查
// 我们不必轮询一个全局的defcon寄存器来得出我们的程序是否已经不稳定了
// 相反,我们假设任何东西都正确工作,如果有一些没在意料中的发生
// 当前的活动会被停止并且我们的异常控制器将会决定下一步执行哪些程序

// JavaScript的异常管理灵感来自于Java
// Java的异常管理的灵感来自C++
// C++是一个没有合格的内存管理的语言,所以当出差错的时候,每一个在调用链中的函数都需要明确地释放任何一些它开辟的内存
// JavaScript有一个好的内存管理,但是它是呈现了C++的错误内存模型的实现

// 用throw语句来发出故障信号
// c++本来有一个raise语句类似于Ada语言
// 但是单词raise在C的库中已经被定义了
// 所以C++把它设为保留字,没有人愿意用

// JavaScript允许你throw任何的值.throw一些被Error构造器创建的东西比较常见
// 但是这根本不必要.
// 你可以throw任何字面量
// 在C++和Java,异常对象是麦高芬,macguffin(自行百度)
// 这里的意思就是体现异常最重要的是异常里面的传递的信息,而不是异常对象本身,但是在C++,Java这样的强类型语言中,对象类型又是必要的
// 在写得好的JavaScript中,异常对象是多余的

throw "that does not compute.";

// try语句会把一个异常控制器(exception handler)附在一个代码块上
// 异常控制器被包装成一个catch的子句
// 它允许接收一个参数
// 这就是它如何接收任何throw语句抛出的东西的方式

try {
    here_goes_nothing();
} catch {
    console.log("fail:here_goes_nothing");
}

// 如果任何东西在try中抛了个异常,然后catch语句执行

// try的设计允许非常细粒度的异常管理
// 在函数中每一个语句都可以有它自己的try和它自己的catch
// 它甚至允许try语句包含try语句
// 更不好的是,它允许catch语句包含try语句
// try语句和catch子句能够包含throw语句
// 一个函数不应该包含多余1个try

/**
 * unwinding
 */

 /**
  *
  */