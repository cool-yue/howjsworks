/**
 * How Exceptions Works
 */

 // 程序员是乐观主义者.经常都会有一个隐性地假设在我们的程序中,这个假设是所有东西都能够正确执行
 // 但是就算是一个乐观主义者,也知道有时候事情会出错

// 有一个可能性,我们以一个没想到的方式来调用一个函数可能会失败.
// 这在使用第三方代码库的时候尤为顾虑
// 耦合的某种层面来讲就是失败的模式(one of the dimenstions of coupling is failure modes)
// 当失败的时候,应该发生什么?
// 整个代码是不是都失败?
// 我们是不是应该再次调用那个函数并且希望一个更好的输出呢?
// 错误的结果如何来进行交互?

// 这个问题的最受欢迎的解决方式是exception handling(后面称呼为异常控制)
// 这个机制让我们解放自我去更乐观地写代码
// 我们不必为在每一个返回值中的难以理解的错误代码做检查
// 我们不必轮询一个全局的defcon寄存器来得出我们的程序是否已经不稳定了
// 相反,我们假设任何东西都正确工作,如果有一些没在意料中的发生
// 当前的活动会被停止并且我们的异常控制器将会决定下一步执行哪些程序

// JavaScript的异常管理灵感来自于Java
// Java的异常管理的灵感来自C++
// C++是一个没有合格的内存管理的语言,所以当出差错的时候,每一个在调用链中的函数都需要明确地释放任何一些它开辟的内存
// JavaScript有一个好的内存管理,但是它是呈现了C++的错误内存模型的实现

// 用throw语句来发出故障信号
// c++本来有一个raise语句类似于Ada语言
// 但是单词raise在C的库中已经被定义了
// 所以C++把它设为保留字,没有人愿意用

// JavaScript允许你throw任何的值.throw一些被Error构造器创建的东西比较常见
// 但是这根本不必要.
// 你可以throw任何字面量
// 在C++和Java,异常对象是麦高芬,macguffin(自行百度)
// 这里的意思就是体现异常最重要的是异常里面的传递的信息,而不是异常对象本身,但是在C++,Java这样的强类型语言中,对象类型又是必要的
// 在写得好的JavaScript中,异常对象是多余的

throw "that does not compute.";

// try语句会把一个异常控制器(exception handler)附在一个代码块上
// 异常控制器被包装成一个catch的子句
// 它允许接收一个参数
// 这就是它如何接收任何throw语句抛出的东西的方式

try {
    here_goes_nothing();
} catch {
    console.log("fail:here_goes_nothing");
}

// 如果任何东西在try中抛了个异常,然后catch语句执行

// try的设计允许非常细粒度的异常管理
// 在函数中每一个语句都可以有它自己的try和它自己的catch
// 它甚至允许try语句包含try语句
// 更不好的是,它允许catch语句包含try语句
// try语句和catch子句能够包含throw语句
// 一个函数不应该包含多余1个try

/**
 * unwinding
 */

 // 异常管理的一个保证的重要目标是正确运行的程序不会有性能上的损失
 // 性能损失可能发生在异常的抛出,但是那个应该很少发生,并且就算发生它对于性能的影响也不是非常的昂贵

 // JavaScript编译器在编译每一个函数时都为其创建了一个catchmap
 // catchmap把函数体中的指令的位置映射到catch语句,catch语句处理这些指令位置(比如哪一行报错的信息)
 // 正常没出错的程序的执行是没有用到catchmap的

 // 当一个throw语句执行的时候,抛出一个异常,就会去查询当前函数的catchmap,如果存在一个指定的catch语句
 // 然后就拿到控制权并且代码的执行从这个catch的语句位置继续执行

 // 如果没有指定的catch语句,然后我们再看caller(在function章节或者mdn里面有描述).
 // caller现在就是当前函数（函数的外部函数）,调用上一个函数（之前运行没找到异常的函数）的语句就是执行失败的位置
 // 然后再次查找catchmap
 // 如果有一个指定的catch语句,
 // 然后它就拿到控制权并且执行代码从这个catch继续执行

 // 随着这个过程的执行,从call stack往下走,直到有一个catch语句被找到
 // 当call stack空了,我们就有一个uncaught exception

 // 这是一个简单和优雅的机制.它允许把大部分注意力放在成功执行上面但又不会完全不管失败执行
 // 但是这个又容易误用

 /**
  * Ordinary Exception
  */

  // 最常见的异常的误用就是用他们来交互正常的结果
  // 例如,给一个函数读一个文件,文件未找到错误应该不是一个异常
  // 它是一个正常的发生的事情
  // 异常应该只被用在不能被预期的问题

  // Java语言鼓励异常的误用,这样在它的类型系统中(type system)作为一种解决问题的方式
  // 一个java方法只能返回一个单一类型的结果
  // 所以异常被使用作为一个可选的方式来返回类型系统(type system)不允许的普通的结果
  // 这就会导致多个catch子句附在单个try的代码块
  // 它这种方式会很困惑因为普通的结果就跟异常混在了一起

  // 它像一个FORTRAN分配的GOTO语句,一个变量存跳转的目标地址
  // catch语句必须被正确地组织来保证正确的子句被选中了
  // 选择不是基于像switch语句中的任何类型的相等,而是基于同一类型原则,这个原则自身就是一个令人讨厌的东西
  // 任何类型系统（type system）需要明确的分配类型,是残缺的

  // 路径的控制被创造异常对象的方法来决定
  // 那样会在thrower和catcher中造成紧耦合,这个违背的干净的模块化设计

  // 从这样一团糟的里面有很多路径,这样给释放分配的资源的工作非常具有挑战性
  // 所以finally子句被加进来缓解这个问题
  // finally子句是一个不需要参数的函数
  // 它会从每个try的退出点和每个catch的退出点隐式地执行

  // JavaScript,从另外一方面,提供了更干净的实现
  // 如果try是成功的,我们既获得了一个好的结果或者又是一个好的描述
  // JavsScript的type system足够灵活地来处理所有意料中的事情

  // 如果有些确实没预料的事情发生,然后catch子句开始运行,然后另外一个故事开始了
  // 既可以关闭又可以开始

  // 我走Plan A。如果那个成功,我们很棒,如果失败了,我们直接走plan B

  try {
      plan_a();
  } catch {
      plan_b();
  }

  // 推断错误的回复是很复杂的
  // 测试它更加复杂
  // 所以我们应该以简单和可靠的模式来实践
  // 让所有的可期待的结果放在return values
  // 为了异常而节约异常

  // 问题是有很多程序被 其他语言的经验所带坏的程序员 开发的
  // 当应该使用return的时候,他们使用throw
  // 他们创造了复杂的catch子句来解决一些无法解决的问题
  // 然后维护不可以维护的不变的东西
  // 他们使用finally,这个JavaScript并不需要的东西来尝试清理他们的烂摊子


  /**
   * Eventuality
   * 事件驱动编程
   */
  // 异常的工作是通过向下贯穿调用栈
  // 抛出来的值可以跟调用栈中更低的被调用的函数进行交互
  // 在事件驱动的编程中,在每一个turn之后,栈是空的
  // 时间旅行(time travel)不能够将一个抛出值传送到已经不存在的活动代码
  // 异常限制了可用性
  // 它们只能够在当前的时间帧中播报本地的问题(同步的)
  // 后面会详细讨论

  /**
   * Security
   */
  //

  /**
   * Reliability
   */
  // 当有些东西有了很严重的错误,我们能期待一个程序去做些什么?
  // 一个函数调用另外即将工作的并且存在一个异常的函数
  // 但是假如它不能工作
  // 异常对象告诉函数,形参已经超过范围了或者对象不可更改,或者一些其他错误
  // 期待一个函数能够正确工作,就当前技术的等级,并不合理

  // 异常对象中的失败细节对于程序员去知道这些可能会很重要也很有用
  // 但是它不是传送给程序员,而是那些信息传给了一个函数,这样就没有很好的使用到异常
  // 我们已经破坏了信息流.
  // 那些信息应该传给程序员
  // 也可以是以日志流的形式吧
  // 但是现在却是它被向下传送到调用栈,这个会导致误解和遗忘
  // 异常已经导致了我们错误地设计了系统
  // 异常机制它自身都在导致不可靠性

  /**
   * conclusion
   */

   // 不需要finally
   // 可以预测的结果用return,不可预测的才是异常处理的范围