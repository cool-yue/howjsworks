/**
 * How Purity works
 */

 // 函数式编程作为用函数来编程是非常明智的
 // 不幸的是,它是个模棱两可的定义
 // 它可以表示用数学函数来编程,这个函数映射一个域的值到一个范围的值
 // 它可以用软件的函数来编程,这个在大多数编程语言中意味着语句的参数化字符串

 // 数学函数相比软件函数被认为是更纯粹的
 // 纯粹被可改变给打破
 // 一个纯粹的函数不会引起改变
 // 一个纯粹的函数不会被改变所影响
 // 一个纯粹的函数的结果只会被它的输入决定
 // 它不做其他的行文除了提供一个输出
 // 一个给定的输出总是制造一个同样的输出

 // JavaScript,在另外一方面,就像是在颂扬改变
 // 赋值操作符就是原则上的改变装置
 // JavaScript有15个这样的装置
 // 或者有17个,如果你把++和--各自算成2次,就有下面这些:

 // = 赋值
 // +=加赋值
 // -=减赋值
 // *=乘赋值
 // /=除赋值
 // %取余
 // **指数
 // >>>= 右移位赋值
 // >>=右移位带符号赋值
 // <<=左移位赋值
 // &= 位与赋值
 // |= 位或赋值
 // ^= 位亦或赋值
 // ++ 前加
 // ++ 后加
 // -- 前减
 // -- 后减

 // 像所有的主流程序一样,JavaScript喜欢溅射污染别的地方,喜欢对清晰的东西进行改变
 // JavaScript选择给 = 来改变(不纯粹),而不是当做等使用(纯粹的)

 /**
  * The Blessing of Purity
  */
 // 纯粹伴随着一些有价值的好处
 
 // 纯粹通常意味着非常好的模块化
 // 纯粹函数有非常好的内聚性
 // 在函数中的每个东西都只是为了得到最后那个结果
 // 没有别的东西能够发生在削弱内聚的那一边
 // 纯粹函数有很松的耦合性
 // 一个纯粹的函数只依赖于它的输入
 // 好的模块的构造非常难,但是有了纯粹,好的模块化就自然出现

 // 纯粹函数能够非常简单地进行测试.
 // 因为它们只依赖于它们的实参,因此没有必要去mock,fake或者stub
 // 一旦我们看到一个纯粹的函数从一个输入中返回了一个正确的结果
 // 我们就知道在当前环境中没有改变能够导致这个纯粹的函数返回别的值
 // bugs就不见了当你被由于不纯粹的东西导致你反复的断电和通电

 // 纯粹的函数非常容易组合
 // 由于他们没有副作用和没有外部依赖或者影响
 // 把他们组装到更大的更复杂的函数,这个函数依旧是纯粹并且可组合的

 // 有一天纯粹将会提供一个性能巨大的提升
 // 纯粹提供了一个非常好的解决方案对于困扰着线程的可靠性和性能问题
// 在多线程系统中,如果2个线程在同一时间尝试访问同一块内存
// 那么竞争就出现可能会导致数据的损坏或者系统的错误
// 这样的竞争非常难以诊断
// 互斥锁能够缓解这个竞争
// 但是会导致延迟,死锁或者系统错误

// 纯粹的函数能够让线程安全和高效
// 由于纯粹的函数不会导致改变
// 内存的共享并没有制造风险
// 一个数组的map方法,给了一个纯粹的函数,可以把数组的元素分发到所有可用的核心上
// 计算就会很快处理.性能的改善基本上是线性的
// 核心数越多,越快
// 这样就有大量的一类程序能够从中受益

// 总有很多很蠢的特性被考虑到并入JavaScript中
// 很多它们的这一类都被并入
// 它们都是让我们分心的东西
// 纯粹函数的并行操作使我们需要的

/**
 * getting Pure
 */

 // 伴随着纯粹有非常数量明确的好处
 // 所以我们可以在我们的语言中添加纯粹？
 // 不,纯粹不是一个能够添加的特性
 // 它就像稳定性和安全性一样
 // 我们不能把稳定性添加给一个系统
 // 取而代之我们必须移除导致不稳定性的东西
 // 我们不能够添加安全性,取而代之我们必须移除那些不安全的东西
 // 我们不能够添加纯粹,但是我们可以移除不纯粹
 // 不纯粹是那些背离数学模型的函数的腐败的东西

 //ECMA没有能力在JavaScript中移除坏的部分,这也是为什么坏的部分持续增加
 // 但是你可以选择不使用这个坏的部分
 // 我们能够让语言为我们自己而纯粹,通过带来更多的处理过程中的规则
 // 如果我们决定从来不使用不纯粹的特性
 // 那个不纯粹特性就不能够削弱和不纯粹化我们函数体的本质

 // 所以让我们做一个快速的语言不纯粹的调查

 // 显然,我们应该清理所有的赋值操作符,同样也有var,let语句
 // 我们可以保留const语句,它穿件并且初始化一个变量,但是不能够让它被修改

 // 我们必须摆脱操作符和方法来修改对象
 // 包括delete操作符和像Object.assign这样的方法
 // 我们必须摆脱数组的修改方法,像splice和sort
 // 数组的sirt方法本来可以是个纯粹的函数,但是它的实现修改了原始的数组,所以它出局

 // 我们必须摆脱使用getter和setter.setter显然是修改的仪器,而且还会制造副作用
 // 所有的副作用都是坏的并且必须被消除

 // RefExp exec方法改变了lastIndex属性,所以它出局,它本来可以设计得更好,但是它没有

// for语句的目的是修改指示变量,所以它也要出局
// 我们也应该摆脱while和do
// 尾调是一个纯粹形式的迭代

// 我们必须摆脱Date构造器,每一次我们调用它,我们都拿到一个不同的值
// 那样就不纯粹.我们也应该摆脱Math.random,你从来都不知道他将会给你什么

// 我们必须摆脱用户,每一次和人的交互都会返回一个不一样的结果。人类是不纯粹的

// 最终,我们必须拜托网络,lambda calculus没有办法在一台或者其他的机器上传达讯息
// 相似的,普遍的图灵机器没有WiFi连接器

/**
 * The Problem With The Universe
 * 天地万物的问题
 */

 // 宇宙万物是不纯粹的.万物是事件性的,充分地分散,并且高并行
 // 我们的编程模型必须接受这样的现实
 // 如果我们的程序跟宇宙万物进行交互
 // 尤其是宇宙万物中的人这个代理
 // 然而我们的程序有一部分必须是不纯粹的

 // 我们应该尝试让我们的程序尽可能地去纯粹因为纯粹的好处是真实的
 // 对象仍然是有价值的尽管它们有状态,并且状态仅仅关心它是否可变
 // 我们应该设计我们的对象那样它们状态的修改就会被规则化和紧紧地被控制住

 /**
  * Continuum
  */
 // 纯粹将会很容易地被推断它是两者之一：一个函数是纯粹要么不纯粹
 // 不幸的是比那个更复杂的是,有太多方式我们来思考关于纯粹性了
 
 // 修改是不纯粹的,但是终归,就算是最纯粹的系统,它也有不纯粹的部分在它内部
 // 一个函数式系统总是创建新的活动对象,并且把一个对象从可用内存移动到当前活跃内存中并且反向的操作这个过程需要修改
 // 这不是一个坏的事情
 // 总体来说,我们要尽量多的东西纯粹
 // 不纯粹的东西应该被影藏

 // 13章节的generators和17章节的对象把它们的状态隐藏得很好
 // 在外部的代码只能够通过generator的实行规则和方法来进行修改
 // generators和对象不能够被外部的赋值进行修改
 // 他们不是完全的纯粹,但是它们对于另外一个面向对象的模式来说,做了很有意义的改进
 // 他们就是我们处理纯粹边界问题的例子

 // 一个纯粹的定义是不使用赋值和其他的修改操作,所以这个是纯粹的吗?

 function repeat(generator) {
     if (generator() !== undefined) {
         return repeat(generator)
     }
 }

 // repeat函数接受一个generator函数并且调用它知道返回undefined
 // 函数体是纯粹的,但是精神不纯粹.它自己没有做出不纯粹的行为,但是它让generator不纯粹了
 // 很多告诫函数都是在这样一个中间的位置

 // 一个函数做一个赋值操作并且仍旧被认为是纯粹的是可行的
 // 如果一个函数申明局部变量,并且用循环和赋值来改变这些变量,然而它看起来是不纯粹的
 // 但是我们可以给这个函数放到一个并行的map函数中,它运行还是对的
 // 它是精神的纯粹而函数体不纯粹
 // 当黑盒子看,它是纯粹的
 // 如果我们往里面看,它就是不纯的

 // 所以有一个纯粹的连续体
 // 数学函数排在顶头
 // 放在并行应用中是足够纯粹的函数
 // 然后纯粹高阶函数
 // 然后状态化的高阶函数
 // 然后污染web的公里级溅射：类风格的,过程风格,并且在最底层,每一个东西都用全局变量
