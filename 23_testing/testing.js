/**
 * How Testing Works
 * 程序测试能够用来展示有哪些bug,但是从来不会展示bug不存在！
 */

 // 电脑程序是人类创造的最复杂的东西
 // 没有别的东西是由这么多错综复杂的东西组成并且还都需要互相适配然后完美地协同工作
 // 一个完成的程序必须在每方面都完美(perfect)
 // 对于所有的输入,对于所有的状态,对于所有的条件,对于所有的时间
 // 我们跟计算机之间的合同是如果我们给了一个不是很完善的程序,那么计算机就有资格做可能最坏的时间里面做最差的事情
 // 这不是计算机的错,这是你的错

 // 我们没有一个针对完美性的测试
 // 我们可以证明一个程序存在缺陷,但是我们不能证明一个程序没有缺陷
 // 测试可以作为是正确工作的证据
 // 一个程序以完美性的数学证据来进行开发的想法
 // 这个被当做在计算机科学中最重要的突出的问题
 // 但是不幸的是,它从来没有被解决
 // 证据要比程序它们意图证明的要复杂很多
 // 复杂性是压倒性的

 // Robin Milner 和其他一些提议type类型的可靠性可以成为一个更实际的另外一种证据
 // type能够比验证更加简单地集成进程序
 // Milner著名地说出,良好的type程序不会"出错"
 // 但是在那些拥有良好type系统的语言,像haskell,还有那些拥有非常糟糕的type系统的语言,像C++,Java
 // 程序还是会出错.可能有一天type会还债,只是现在还没有到时候

 // 随着数学验证和type的失败,我们把我们知道得并不完美的程序放入产品模式(production)
 // 希望我们能够在任何人发现错误之前发现并且修改错误
 // 这个很疯狂,这个是当时的技术水平

 // 应该有更好的方式,但是如果有,当时还没有人发现它

 // 所以这个把我们带回了测试
 // 测试,当做得很好的时候,能够识别出缺陷并且给我们信心缺陷已经修复了
 // 甚至当测试做得很好了,依然不能证明bug已经没了
 // 然而呢测试不是总是做得很好的

 // 在70年代末期和80年代初期,Atari比地球上面其余的公司卖出更多的软件到更多人
 // 大部分的软件都是烧进ROM(read only 内存)chips
 // ROM里面的错误能够被修正
 // 你必须把它们丢掉然后重新做个新的
 // Atari做了一个拥有一个操作系统在rom中的家用电脑
 // 我确实对那个印象很深
 // 他们编程是哪里来的信心把那个东西放进ROM里面.它们是怎么做的?

 // 我作为一个研究者在Atari合作实验室里面工作.
 // 这个让我找到了Atari是如何做的
 // 这也是他们的秘密
 // 他们会把那些东西试一试
 // 如果它看起来可以工作
 // 他们就会把它送到工厂
 // 他们很幸运
 // 当他们的ceo宣布E.T.这个游戏不需要更多测试的时候,他们的运气也耗尽了
 // 他们的公司没有活过那个决定
 
 // 程序在那个时候是要小很多和简单很多。
 // 如果一个程序只有几多KB的话
 // 认真的写代码,认真的测试能够产出一个好的结果
 // 今天的程序是庞大的.没有人可以把它们所有的都理解
 // 我们怎么能确定太复杂以至于不能够理解的东西，它是正确的？

 /**
  * bugs
  */
 // bugs是被thomas alva edison发明的
 // 他真在开发他的留声机，这是一个录音然后通过用箔纸包装的周围包着一个旋转的圆柱体的薄片上的触笔来创造声音的设备
 // 他的这个原型，在每一次这个触笔旋转穿过箔纸薄片的边缘的时候会发出声音
 // Edison给一个记者说道他弄了一整晚来把虫子从留声机里面弄出去

 // 这个词疯狂流行了
 // 多年来有很多故事关于疯狂发明家他们把他们的发明中的最后一个虫子弄出去而一夜暴富的故事

 // 有一个非常有名一个飞蛾被困在了Harvard Mark II机器的中继器中的故事
 // Grace Murray Hopper把那个飞蛾用哪个胶带粘在它的日志本里面
 // 带着“第一个实际的发现虫子的案例”的说明文字
 // 这不是第一个bug,但是它是第一个被昆虫导致的bug
 // 尽管有正当的理由bug是被人工智能潜在造成的,但是大多数还是人类造成的

 // 我们必须尝试劲量终结我们的程序中的困惑
 // 当我们期待一个程序做一件事的时候它做了其他的事情
 // 这个就会让我们对于程序变得困惑
 // 我们必须让我们的程序劲量简单和干净来减少困惑
 // Bug就是Confusion的另外一个单词
 // 消除困惑比测试更加富有成效

 /**
  * Bloat
  */

  // 软件开发中的一个最大问题之一是软件肥胖或者膨胀
  // 程序太大了。
  // 这个可以是由于非成熟特性的选择,但是通常是差的架构导致的
  // 继承是一个很流行的代码复用模式
  // 但是它并不能很好地工作,所以拷贝-粘贴经常被使用
  // 也存在过度依赖库,平台和一些包,这些跟很多其他的库,平台,包存在紧耦合
  // 膨胀是敏捷开发实践的副作用
  // 开发团队被扩大来处理膨胀,但是大的团队导致了更多的膨胀

  // 膨胀导致被攻击面增加和给bug更多的位置隐藏导
  // 致的安全问题
  // 膨胀的系统非常难以准确地测试