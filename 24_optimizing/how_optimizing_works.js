/**
 * How Optimizing Works
 */

// 初始几代的计算机，以现代的标准来看，非常慢。
// 正如拿到一个过于晚的正确的结果跟失败得到一个结果没有区别。
// 性能优化在编程中变成了一个根深蒂固的痴迷

// 今天的设备要快得多.所以好像性能不再是个忧虑。
// 并且对于大多数app,不需要考虑性能。
// 我们有了比我们需求的更多的处理器
// 大部分时候这些处理器都是发呆状态
// 我们有非常过剩的处理能力

// 一些东西还是不够快。
// 有时那个是因为这个问题的规模增长地快过了我们的处理能力
// 大数据持续着越来越大
// 甚至是在人类交互的范围,这是JavaScript统治着的领域，我们还是会经历着缓慢的处理速度

// 当我们花了太长时间把我们的响应返回给人类，他们会很烦恼，然以他们感到挫败，然后他们开始愤怒
// 如果我们尝试着创造满意度和忠诚度，那么我们的系统就必须快速响应

// 所以还是有必要顾虑到西能，但是我们需要正确地去处理
// 优化也能够轻易让事情变得更糟

// 人们普遍认为每一个小的优化都是有用的，因为所有的这些都节约的纳秒都可以加起来
// 这个是不对的.我们应该仅仅优化我们能够获得非常可观的改善的地方
// 不是很可观的优化是浪费时间
// 优化的宗旨是节约时间
// 所我们需要优化我们的优化代码方式。

/**
 * Measurement
 */

 // 计算机编程也熟知为计算机科学和软件工程。
 // 这些是充满渴望成功的名号
 // 我们对这些没有足够的理解，来真正去做科学和工程
 // 我们也没有理论来回答在一个软件项目管理中的最重要的问题
 // 还要多少bugs剩下?还要多久能够修复它们?

 // 我们的艺术有太多的不够格但是我们却可以去衡量性能
 // 我们可以执行一个程序,然后观察它花了多长时间
 // 这些数值能够帮助我们更好地理解我们的系统,或者他们也能让我们困惑

 // 一个非常通用的实践是拿2个语言的特性，把他们全部放进循环然后衡量这个循环
 // 快的哪一个告诉我们使用哪一个特性,这个是有问题的

 // 这个结果是没有意义的.我们是在测试那个特性的性能或者是我们在测试引擎优化那个特性的能力
 // 当你把它隔离出来在一个循环中执行100万次?
// 这个结果能够到处通用么?
// 其他的引擎是不是也性能表现得一致?
// 更重要的是,未来的引擎也是以同样的方式来执行么?

// 结果可能没有意义.在我们的上下文中,它是一个实实在在的程序,可能不存在一个可以观测的不同点
// 所以我们可能在浪费时间来基于意义数据的决策

// 我们应该取而代之去用这个特性来给我们程序可读性和可维护性
// 如通它只是快但是又是个坏的代码,这个并不会帮到我们
