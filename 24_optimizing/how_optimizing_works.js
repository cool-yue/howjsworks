/**
 * How Optimizing Works
 */

// 初始几代的计算机，以现代的标准来看，非常慢。
// 正如拿到一个过于晚的正确的结果跟失败得到一个结果没有区别。
// 性能优化在编程中变成了一个根深蒂固的痴迷

// 今天的设备要快得多.所以好像性能不再是个忧虑。
// 并且对于大多数app,不需要考虑性能。
// 我们有了比我们需求的更多的处理器
// 大部分时候这些处理器都是发呆状态
// 我们有非常过剩的处理能力

// 一些东西还是不够快。
// 有时那个是因为这个问题的规模增长地快过了我们的处理能力
// 大数据持续着越来越大
// 甚至是在人类交互的范围,这是JavaScript统治着的领域，我们还是会经历着缓慢的处理速度

// 当我们花了太长时间把我们的响应返回给人类，他们会很烦恼，然以他们感到挫败，然后他们开始愤怒
// 如果我们尝试着创造满意度和忠诚度，那么我们的系统就必须快速响应

// 所以还是有必要顾虑到性能，但是我们需要正确地去处理
// 优化也能够轻易让事情变得更糟

// 人们普遍认为每一个小的优化都是有用的，因为所有的这些都节约的纳秒都可以加起来
// 这个是不对的.我们应该仅仅优化我们能够获得非常可观的改善的地方
// 不是很可观的优化是浪费时间
// 优化的宗旨是节约时间
// 所我们需要优化我们的优化代码方式。

/**
 * Measurement
 */

 // 计算机编程也熟知为计算机科学和软件工程。
 // 这些是充满渴望成功的名号
 // 我们对这些没有足够的理解，来真正去做科学和工程
 // 我们也没有理论来回答在一个软件项目管理中的最重要的问题
 // 还要多少bugs剩下?还要多久能够修复它们?

 // 我们的艺术有太多的不够格但是我们却可以去衡量性能
 // 我们可以执行一个程序,然后观察它花了多长时间
 // 这些数值能够帮助我们更好地理解我们的系统,或者他们也能让我们困惑

 // 一个非常通用的实践是拿2个语言的特性，把他们全部放进循环然后衡量这个循环
 // 快的哪一个告诉我们使用哪一个特性,这个是有问题的

 // 这个结果是没有意义的.我们是在测试那个特性的性能或者是我们在测试引擎优化那个特性的能力
 // 当你把它隔离出来在一个循环中执行100万次?
// 这个结果能够到处通用么?
// 其他的引擎是不是也性能表现得一致?
// 更重要的是,未来的引擎也是以同样的方式来执行么?

// 结果可能没有意义.在我们的上下文中,它是一个实实在在的程序,可能不存在一个可以观测的不同点
// 所以我们可能在浪费时间来基于意义数据的决策

// 我们应该取而代之去用这个特性来给我们程序可读性和可维护性
// 如通它只是快但是又是个坏的代码,这个并不会帮到我们

/**
 * Measure again
 */

 // 木匠有一个格言：“测量2次，锯1次”
 // 它看起来能够很简单地优化，“测量1次，锯1次”。额外的那一次减少了错误
 // 避免浪费时间和材料。它是个巨大的胜利

 // 程序员需要用这个格言。“测量,然后锯，然后再测量”
 // 在做优化之前，我们应该先测量我们想优化的代码的性能
 // 我们做这个是建立一个基准线并且作为演示来表示那一部分的代码降低了整个系统的速度
 // 如果代码并不“发热”（code is not hot）,然后我们应该看其他地方
 // 然后我们仔细地优化代码.然后我们再次测量
 // 如果新的代码并没有很大层度地好过基准线
 // 然后我们回滚
 // 这个优化的意图是失败地，我们不提交失败地优化

 // 大多数的优化为代码增加了复杂度，通过增加的可选的代码路径和移除了通用性
 // 这个让代码更大，更难去优化，并且更难去合格地测试
 // 我们可以考虑，如果这个它能够获得一个很可观的速度提升，我们认为这是值得的
 // 如果我们没有一个可观的速度提升，我们可以认为这个改变是个bug
 // 它导致代码的质量变差了或者并没有补偿到收益点（收益小于代价）
 // 干净的代码能够更简单地去思考推导和维护
 // 我们不应该放弃这个

 // 大多数的代码有一个对于性能有忽略不计的影响
 // 这个浪费时间去优化那些并没有减慢速度的代码

 /**
  * Time suck
  */

  // 很少有这种情况,摆弄代码能够让代码更快，因为摆弄代码并没有解决底层导致变慢的原因
  // 这里有一些很大层度上导致时间缓慢的恶心东西

  // failure to parallelize:
  // 失败地并行（没有处理好并行）
  // parseq让我们能够利用通用的并行机制来让事情更快。如果相反我们让任何东西都序列化执行，我们还是放弃吧
  // 在某些规模上,并行打败序列化

  // violating the Law of Turns:
  // 违背了turn的法则
  // 当我们阻塞了event loop，这个让任何在未来发生的事情得到延迟直到队列最终变空
  // 积累起来的延迟阻止了队列变空
  // 这里要解释一下,想象一个极端的情况，执行栈里面的代码,如果有死循环,基本上异步队列里面的回调永远不执行
  // 这个异步队列又分为macro和micro，macro每次取出一个，micro清空队列，这样交替下去
  // 比如micro突然来一个死循环，那么下一波的macro就无限延迟了

  // Weak cohesiveness:
  // 差的内聚性
  // 如果我们的模块没有高内聚
  // 那就好像他们做一些它们不需要的事情，不必要的工作让事情变慢
  // 这里的意思是,一个业务逻辑处理了一堆没必要的业务
  // 比如我一个方法有很多个分支,其中有个分支是使用开辟的一个数组
  // 其余的分支使用1万个数组,但是这个程序首先开辟了1万个数组
  // 然后最后这1万个数组可能会使用,也可能只使用其中的一个数组
  // 如果只使用一个数组,那么导致了开辟的1万个数组做了没用的事情
  // 这也是同样导致延迟的原因

  // tight coupling:
  // 紧耦合
  // 当模块紧耦合后,我们放弃了局部性（locality）。
  // 那样会导致过多的聊天协议(chatty protocol)，为每个处理步骤增加网络延迟

  // 作者这里的意思是,放弃局部性之后,很多东西就需要远程取数据,耦合的业务导致chatty protocol的存在
  // 也就是下一个请求必须要上一个请求的获得数据。

  /**
   * Wrong algorithm
   */
  // 一个随心所欲构建的O(nlogn)复杂度的程序很容易就好过精心制作,仔细雕琢优化出来的n^2的函数
  // 当n很大的时候
  // 当n很小的时候,无所谓哪个更快

  /**
   * Thrashing
   */
  // 在虚拟内存中曾经有个问题,这个问题我们在web缓存中任然能看到
  // 从web中有太多从缓存中的垃圾流,在复用这些有用的东西之前,这些垃圾可能把有用的东西给冲掉了
  // 缓存丢失意味着,我们需要重新去取

   /**
    * Bloat
    */
   // 当代码变大膨胀时,我们完全理解它做了什么几乎不太可能
   // 它可能做了很多不必要的东西
   // 不要聚焦于执行速度
   // 聚焦于代码尺寸

    /**
     * Other people's code
     */
    // 你的代码可能依赖于其他的包,库,平台，浏览器，服务器，操作系统
    // 我不知道你的代码必须要跟什么一起运行
    // 但是我可以很有信心,摆弄你的代码不会让依赖的代码更快
    // 如果你的代码执行不耗时间,大部分的web用户将不会观察出很大的不同
    // 上面这句话的意思是,你不可能做到不耗时,但是耗时是谁的锅呢?

    /**
     * language
     */

     // 可能最好的优化的投资是在语言的引擎上
     // 优化植根于那里,造福于所有语言的使用者
     // 这样就会让我们集中精力写一些高质量的程序
     // 引擎的机械学能够让它们更快！

     // 第一个javaScript的引擎是为了上市时间而优化
     // 不用惊讶,它们不是非常快,这个就造成了javaScript是一个玩具语言的故事

     // 即使这样,JavaScript对于大多数web应用还是足够快的
     // 大多数的浏览器中的性能问题是因为误用了网络
     // 序列化地去加载静态资源,而不是pipelineing(pipelining就是多个请求写到一个套接字里面,从而一起发出去)
     // 存在DOM API,这个极度地低效,DOM不是JavaScript的一部分,但是JavaScript因为DOM的性能被抱怨过
     // 更DOM一样坏的是,大部分的web应用足够快运行.JavaScript的运行速度很少是一个因素

     // 从那开始,JavaScript引擎已经变得很快,但是很复杂
     // 所有的简单的优化都做了
     // 从这一点起,事情就越来越复杂
     // 存在优化确实能够在一定的规模加速程序,但是那样又会增加启动时的开销的时间
     // 那是人们变得不耐烦,沮丧,生气的原因之一

     // 所以它们玩了一个很复杂的游戏,它们用慢的代码以快速的方式开始,然后优化程序行为的响应
     // 目前它们已经做得非常好得来玩这个游戏了,但是非常难
     // 他们不能够让任何东西都快
     // 所以这个就变成了一个赌博游戏
     // 他们优化他们想象的东西,将会提供最大化的收益给那些杂音开发者(暗指依赖于各种库的,当前的前端工程化)

     // 随着语言变得更复杂,游戏就越来越难.怪物的数量只会增加,它们从来不减少
     // 最后复杂度将会超负荷,然后游戏结束
     // 一个简单的,干净的,更常规的语言的优化相比来说要简单许多许多

     // 同样也存在一个恶心回馈循环.引擎让某个特性更快
     // 程序员发现那个特性,然后过分重用那些个特性
     // 那样就建立了一个观察引擎的机械力并且受这个影响的一种使用模式
     // 比如a方法性能好,那么就无脑用这个a方法,而不考虑别的
     // 这个循环驱动着优化的投资,但是它不是必然往一个好的程序的方向去驱动
     // 比如函数式编程的时候,鼓励使用递归+尾调来形成循环
     // 然后并不是任何时候都这样,因为考虑到如果有很复杂的循环过程中的控制流
     // 那么这样的递归就要写很多个东西,由于是递归的形式,相比简单粗暴的for循环
     // 递归并不是一下就让人条件发射它在遍历还是做啥,最终如果坚持要用递归,那么可能导致程序可读性的缺失
     // 这到底是不是好的呢？显然不一定是好的程序